\chapter{API reference}
\label{sec:api_reference}

\section{Introduction}
The \ee\ Operating System provides a basic interface for the execution
of concurrent applications on a single processor systems.

The interface proposed is suited for small 8 to 32 bit
microcontrollers, and proposes an architecture where tasks can execute
concurrently exchanging data with a shared memory paradigm. Support
for synchronization primitives is also provided.

Tasks in \ee\ are scheduled according to fixed priorities, and share
resources using the Immediate Priority Ceiling protocol (in case of
the FP kernel) or the SRP protocol (in case of the EDF kernel). In the
case of the FRSH kernel, the scheduling algorithm used is the IRIS
scheduler \cite{iris}, which implements resource reservation with
reclaiming based on the IST FP6 FRESCOR project API \cite{frescor}.

On top of task execution there are interrupts, that always preempt the
running task to execute urgent operations required by
peripherals. Interrupts can be of two kind, names {\em ISR Type 1} and
{\em ISR Type 2} (see Section \ref{sec:interrupt_primitives}).




\subsection{Conformance Classes}
\ee\ implements the minimal API using three conformance classes:
\begin{description}
\item[FP] The Fixed priority (FP) conformance class includes a set of
  functionalities similar to the \ee\ conformance classes BCC2 or ECC2
  (depending if the kernel is configured as monostack or multistack).

  The FP conformance class basically supports fixed priority
  multithreading, with more than one task for each priority, with more
  than one pending activation for each task.

\item[EDF] The Earliest Deadline First (EDF) conformance class
  includes the support for an EDF scheduler. Each task has a relative
  deadline which is computed when the task activation is processed
  (which is at the time of the previous instance if the task has
  pending activations). The deadline is coded using the circular timer
  implementation (see Section \ref{sec:circulartimer}).

\item[FRSH] The FRescor SCheduler (FRSH) conformance class includes
  the support for an EDF scheduler and, on top of it, an
  implementation of the IRIS scheduler \cite{iris} together with the
  implementation of binding/unbinding specific functions.
\end{description}


\subsection{Available primitives}
\ee provides a set of primitives that can be called in different
situations. The complete list of primitives is listed in Table
\ref{tab:api-restrictions}, together with the locations where it is
legal to call these functions.

In addition, Table \ref{tab:api-restrictions-frsh} shows the same
information for the aditional primitives introduced with the
\const{FRSH} Kernel.

The FRSH implementation is different from FP and EDF in many different
aspects. For this reason, most of the details about the \const{FRSH}
implementation will be described separately in Chapter
\ref{cha:frsh}. To avoid repetitions of informations, all the
primitives which have a similar behavior (for example,
\reffun{ActivateTask}) will be reported only once below.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INIZIO PARTE IMPORTATA DA TabellaOSEK.lyx - NON MODIFICARE
% MODIFICATE IL LYX, ESPORTATE e commentate all'inizio ed alla fine!!!
\input{tabellaosek.tex}
% FINE PARTE IMPORTATA DA TABELLAOSEK.LYX - NON MODIFICARE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





%% 
%% Basic template 
%%
%% \begin{function}{FunctionName}
%% \synopsis{}
%%   \begin{fundescription}
%%   \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
%%   \begin{funreturn}
%%   \fret{}{}
%%   \fret{}{(Extended)}.
%%   \end{funreturn}
%%   \begin{funconformance}
%%     BCC1, BCC2, ECC1, ECC2
%%   \end{funconformance}
%% \end{function}


\pagebreak

\section{Constants}
\label{sec:constants}

This is a list of the \ee\ constants that can be used by the developer
for writing applications.

\begin{constant2}{INVALID\_TASK}{INVALID_TASK}
  \begin{constantdescription}
    This constant represent an invalid task ID.
  \end{constantdescription}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{constant2}

\begin{constant2}{EE\_MAX\_NACT}{EE_MAX_NACT}
  \begin{constantdescription}
    This constant represent the maximum number of pending activations
    which can be stored for a given task. Its typical value is the
    maximum value for an unsigned integer on the particular
    architecture.
  \end{constantdescription}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{constant2}

\begin{constant2}{RES\_SCHEDULER}{RES_SCHEDULER}
  \begin{constantdescription}
    This is the ID of the \const{RES_SCHEDULER} resource.

    That resource exists only when \const{USE_RESSCHEDULER} is set to
    \const{TRUE} inside the OIL configuration file. The
    \const{RES_SCHEDULER} ceiling depends on the tasks that exists in
    the system, and it is computed when \rtd\ generates the \ee\ 
    configuration code.
  \end{constantdescription}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{constant2}

\begin{constant}{Task States}
  \begin{constantdescription}
    This is the list of the task states a task can have during its life:
    \begin {lstlisting}
#define EE_READY      1
#define EE_STACKED    2
#define EE_BLOCKED    4
#define EE_WASSTACKED 8
    \end{lstlisting}
    Task States in \ee\ are typically not visible to the application,
    because they are highly dependent on the particular \ee\
    configuration. In particular, when using a monostack
    configuration, task statuses are removed from the system to save
    RAM. The \const{EE_READY} status is used when a task is ready to
    execute but it has not been allocated in its stack yet. The
    \const{EE_STACKED} status refers to a task which is either the
    running task or it has been preempted on the stack. The status
    \const{EE_BLOCKED} considers a task which has executed and which
    is currently blocked on a synchronization primitive (e.g., a
    \reffun{WaitSem} primitive). An additional flag named
    \const{EE_WASSTACKED} is also defined for internal reasons to map
    a ready task which has been woken up from a synchronization but
    which is still in the ready queue waiting to execute.
  \end{constantdescription}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{constant}




%% Nota: questa parte non è ancora generata da RT-Druid!

%% \begin{constant}{xxxx}
%% \nb{Nell'oil un 'counter' deve essere definito come segue

%% COUNTER Counter1 {
%%     MINCYCLE = 1;
%%     MAXALLOWEDVALUE = 16;
%%     TICKSPERBASE = 2;
%% };

%% quindi, con un MINCYCLE, MAXALLOWEDVALUE e TICKPERBASE, che sono anche i valori qui indicati;
%% Pero' questi NON vengono dichiarati nel codice usando delle define, ma inserendone i valori nel vettore

%%     const EE_oo_counter_ROM_type EE_counter_ROM[] = {
%%         {16, 2, 1}         /*Counter1*/
%%     };

%% Mi sembra che torni con quanto indicato su ee/pkg/kernel/oo/inc/ee_common.h

%% Mentre, di TICKDURATION ... NON so nulla : e' la prima volta che lo vedo (forse c'era qualcosa nella primissima versione con H8).

%% Altra cosa: non mi sembra esista un 'counter di sistema'.
%% }
%% \begin {lstlisting}
%% /* these #defines have to be defined by the user or by the HAL!!!
%%    x is the counter */

%% /* Maximum possible allowed value of counter x in ticks. */
%% //#define OSMAXALLOWEDVALUE_x 

%% /* Number of ticks required to reach a specific unit of counter x. */
%% //#define OSTICKSPERBASE_x 
%% /* Minimum allowed number of ticks for a cyclic alarm of counter x. */
%% //#define OSMINCYCLE_x 
%% /* Maximum possible allowed value of the system counter in ticks. */
%% //#define OSMAXALLOWEDVALUE 
%% /* Number of ticks required to reach a specific unit of the system counter. */
%% //#define OSTICKSPERBASE 
%% /* Minimum allowed number of ticks for a cyclic alarm of the system counter. */
%% //#define OSMINCYCLE 

%% /* Duration of a tick of the system counter in nanoseconds. */
%% //#define OSTICKDURATION
%% \end{lstlisting}
%% \end{constant}


\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Types}
\label{sec:types}

This Section contains a description of the data types used by the OS
interface of \ee. When the size of a given type is indicated to be of the
size of a machine register, it is intended that such type has the same
size of the CPU general purpose register.

\begin{type}{AlarmType}
  \begin{typedescription}
    This (signed) type is used to store Alarm IDs, and it has the size
    of a register.
  \end{typedescription}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{type}

\begin{type}{CounterType}
  \begin{typedescription}
    This (signed) type is used to store Counter IDs, and it has the size
    of a register.
  \end{typedescription}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{type}

\begin{type}{ResourceType}
  \begin{typedescription}
    This (unsigned) type is used to store Resource ID values, and it
    has the size of a register.
  \end{typedescription}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{type}

\begin{type}{SemType}
  \begin{typedescription}
    This type is a structure storing the information related to a
    counting semaphore.
  \end{typedescription}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{type}

\begin{type}{SemRefType}
  \begin{typedescription}
    This is a pointer to \reftype{SemType}.
  \end{typedescription}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{type}

\begin{type}{TaskType}
  \begin{typedescription}
    This (signed) type is used to store Task ID, and it has the size
    of a register.
  \end{typedescription}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{type}

\begin{type}{TickType}
  \begin{typedescription}
    This (unsigned) type is used to store Counter Ticks, and it has
    the size of a register.
  \end{typedescription}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{type}

\begin{type}{TickRefType}
  \begin{typedescription}
    This is a pointer to \reftype{TickType}.
  \end{typedescription}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{type}

\begin{type}{TimeAbsType}
  \begin{typedescription}
    This is an absolute timer reference, coded using the circular timer
    method (see Section \ref{sec:circulartimer}.
  \end{typedescription}
  \begin{funconformance}
    EDF, FRSH
  \end{funconformance}
\end{type}

\begin{type}{TimeRelType}
  \begin{typedescription}
    This is a relative timer reference, coded using the circular timer
    method (see Section \ref{sec:circulartimer}.
  \end{typedescription}
  \begin{funconformance}
    EDF, FRSH
  \end{funconformance}
\end{type}


\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Object Definitions}
The following macro have to be used when defining a Task.

\begin{function_nopb}{TASK}
  \synopsis{TASK(Funcname) \{...\}}
  
  \begin{fundescription}
    The TASK keyword must be used when declaring a TASK function.
  \end{fundescription}
  
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function_nopb}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%









\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Task Primitives}

\ee\ minimal API supports the definition of tasks which are similar to the Basic
Tasks of the OSEK/VDX Standard.

\ee\ Tasks are typically implemented as normal C functions, that
executes their code and then ends. One of these executions is called
also {\em Task Instance}\index{Task Instance}. After the end of a
task, its stack is freed. \ee\ tasks typically never block, allowing
the developer to implement stack sharing between different
tasks. Sharing the stack helps the developer to reduce the overall RAM
used for the stack.

Support for blocking primitives like counting semaphores or FRSH
synchronization objects is also available. In these cases, the kernel
has to be configured as multistack, and the tasks using these
primitives will need a private stack assigned to them (note that the
multistack configuration is mandatory for the FRSH kernel
implementation). Tasks using blocking primitives are typically
implemented as a never ending task in which each instance ends with a
synchronization implemented for example as a semaphore wait.

In the conformance class FP, the scheduling policy is a Fixed Priority
Scheduling with Immediate Priority Ceiling and Preemption
Thresholds. As a result, the following case of tasks may be
implemented:
\begin{description}
\item[Full Preemptive Task] A Full Preemptive task is a task that can
  be preempted in each instant by higher priority tasks.
\item[Non Preemptive Task] A Non Preemptive task is like a Full
  Preemptive task that executes all the time locking a resource with
  its ceiling equal to the maximum priority in the system. As a
  result, a non preemptive task cannot be preempted by other tasks:
  only interrupts can preempt it.
\item[Mixed Preemptive Task] A Mixed Preemptive task is a task which
  executes at a higher priority than the priority used to queue it in
  the ready queue (This technique is called {\em Preemption
  Thresholds}).  As a result, preemption between tasks is reduced
  allowing consistent savings in the RAM space used for stacks.
\end{description}

In the conformance class EDF, the scheduling policy is an Earliest
Deadline First implementation with Stack Resource Policy (SRP), and
Preemption Thresholds. Task parameters include the specification of a
relative deadline (specified in the \const{RELDLINE} OIL attribute) as
well as a preemption level (specified in the \const{PRIORITY}
atrribute. As a result, the following case of tasks may be
implemented:
\begin{description}
\item[Full Preemptive Task] A Full Preemptive task is a task that can
  be preempted in each instant by higher priority tasks.
\item[Non Preemptive Task] A Non Preemptive task is like a Full
  Preemptive task that executes all the time locking a resource with
  its ceiling equal to the maximum preemption level in the system. As
  a result, a non preemptive task cannot be preempted by other tasks:
  only interrupts can preempt it.
\item[Mixed Preemptive Task] A Mixed Preemptive task is a task which
  executes at a higher priority than the priority used to queue it in
  the ready queue (This technique is called {\em Preemption
  Thresholds}).  As a result, preemption between tasks is reduced
  allowing consistent savings in the RAM space used for stacks.
\end{description}

In the conformance class FRSH, the scheduling policy is an Earliest
Deadline First implementation with Stack Resource Policy (SRP), and
with deadlines implemented using the IRIS scheduling algorithm
\cite{iris}. In this case, each task is assigned a ``Virtual
Resource'', which is used as a means to control the task execution
time. The VRES parameters which can be specified are a ``budget'',
which is an amount of time that the task can spend every
``period''. The scheduling algorithm basically guarantees that at
least the budget time will be guaranteed to the task every period,
providing a so called ``resource reservation''.


Tasks are activated using the primitive
\reffun{ActivateTask}. Activating a task means that the activated task
may be selected for scheduling and may execute one Task Instance. A
task activation while a task is already waiting its execution or while
being the running task is saved as a pending activation (up to a
maximum number which is implementation defined). Note that EDF
deadlines for a pending activation are computed when the previous
instance ends.

Tasks scheduled with the minimal API are slightly different if
compared with tasks scheduled with the OSEK conformance classes. These
are the main differences:
\begin{itemize}
\item The minimal API does not support the primitives \fn{TerminateTask} or
  \fn{ChainTask}.\
\item The number of pending activations does not need to be specified
  inside the OIL file (as it happens in the BCC2 and ECC2 conformance
  classes of \ee).
\end{itemize}


\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{ActivateTask}
  \synopsis{void ActivateTask(TaskType TaskID);}
  
  \begin{fundescription}
    This primitive activates a task \vr{TaskID}. Upon activation, the
    task may become the running task if it is the highest priority
    ready task (if using the FP kernel) or if it is the task with the
    earliest deadline and with preemption level greater than the
    system ceiling (using the EDF and FRSH kernel)..

    Once activated, the task will run for an instance, starting from
    its first instruction. If the task is activated while being the
    running task, or being ready to execute, the activation is stored
    as a pending activation, which will be handled afterwards. There
    is a maximum number of pending activations. If the maximum number
    of pending activations is exceeded, the activation is
    ignored. Note that for the EDF kernel, the deadline for a pending
    activation is computed when the previous instance ends.

    The function can be called from the Background task (typically,
    the \fn{main()} function).

  \end{fundescription}
  
  \begin{funparameters}
    \fpar{TaskID}{Task reference.}
  \end{funparameters}
  
  \begin{funreturn}
    \fret{void}{The function never returns an error.}
  \end{funreturn}
  
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{Schedule}
  \synopsis{void Schedule(void)}
  \begin{fundescription}
    This primitive can be used as a rescheduling point for tasks that
    uses Preemption Thresholds and for non preemptive tasks.

    When this primitive is called, a task using preemption thresholds
    sets its priority to the (lower) one used when queuing on the
    ready queue. Then, the system checks if there are higher priority
    tasks that have to preempt (in that case, a preemption is
    implemented). When the primitive returns, tasks using preemption
    thresholds will reacquire its threshold priority.
    
    The primitive has no effect if the calling task is neither a
    non-preemptive task, neither a task using preemption thresholds.
  \end{fundescription}
  \begin{funreturn}
    \fret{void}{The function never returns an error.}  
  \end{funreturn}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Resource primitives}
\label{sec:resource-primitives}
Resources refer to binary semaphores used to implement shared critical
sections.

Resources are implemented using the Immediate Priority Ceiling
protocol (FP kernel), or using the Stack Resource Policy (EDF and FRSH
kernel).
%
%
% \nb{mettere link alla sezione di Peppe}
%
%
A resource is locked using the primitive \reffun{GetResource}, and
unlocked using \reffun{ReleaseResource}.

A special resource named \refconst{RES_SCHEDULER} is also supported
for kernels FP and EDF. The \refconst{RES_SCHEDULER} resource has a
ceiling equal to the highest priority (FP or highest preemption level
in the case of EDF) in the system. As a result, a task locking
\refconst{RES_SCHEDULER} becomes non-preemptive. If needed, the
\refconst{RES_SCHEDULER} resource have to be configured in the OIL
configuration file.

In the FRSH Kernel implementation, preemption due to VRES budget
exaustion during critical sections is disabled. This approach has also
been analyzed in the literature as ``overrun and payback'' mechanism
by \ref{ghazalie95} and \ref{davis06} w.r.t. a task continuing to
execute when its budget runs out but it is holding a resource. In that
case, the task budget becomes negative and the time consumed in excess
will be borrowed from the next task instances (in pathological cases a
task may be forced not to schedule for a few instances due to that, as
shown in \cite{frescor_ep7v2}). The rationale behind this choice is
that it is too costly on a microcontroller to implement some control
over the time a task owns a resource. Being the application
environment somehow controlled, there is hope that the designer will
not abuse of the timing spent in a critical resource. Please note that
also binding and unbinding is disabled when a task owns a resource

\pagebreak


\begin{function}{GetResource}
  \synopsis{void GetResource (ResourceType ResID)}
  \begin{fundescription}
    This primitive can be used to implement a critical section guarded
    by Resource \vr{ResID}. The critical section will end with the
    call to \reffun{ReleaseResource}.

    Nesting between critical sections guarded by different resources
    is allowed.

    Calls to \reffun{Schedule} are not allowed inside the critical
    section.

    The service may be called from task level only.
  \end{fundescription}
  \begin{funparameters}
    \fpar{ResID}{Reference to resource}
  \end{funparameters}
  \begin{funreturn}
    \fret{void} {The function does not return an error.} 
  \end{funreturn}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{ReleaseResource}
  \synopsis{void ReleaseResource (ResourceType ResID)}
  \begin{fundescription}
    \fn{ReleaseResource} is used to release a resource locked using
    \reffun{GetResource}, closing a critical section.
    
    For information on nested critical sections, see \reffun{GetResource}.

    The service may be called from task level only.
  \end{fundescription}
  \begin{funparameters}
    \fpar{ResID}{Resource identifier}
  \end{funparameters}
  \begin{funreturn}
    \fret{void} {The function does not return an error.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function}

\pagebreak



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Interrupt primitives}
\label{sec:interrupt_primitives}

The minimal API gives support for interrupts. Interrupts are modeled considering
typical microcontroller designs featuring interrupt controllers with a
prioritized view of the interrupt sources.

To map the requirements of fast OS-independent requests, \ee\ supports
the definition of fast interrupts handlers, called {\em ISR Type 1},
that on one side can handle interrupts in the fastest possible way,
but on the other side lack the possibility to call OS services. 

On the other hand, lower priority interrupts, called {\em ISR Type 2} and
used (for example) for hardware timers, can call selected OS primitives
but are slower than ISR Type 1 due to the OS bookkeeping needed to
implement preemption.

Most of implementation details related to IRQ handling highly
depends on the particular microcontroller on which \ee\ is
used. Please refer to the documents related to the porting of \ee\
to the specific architecture for further details.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Counter and Alarms primitives}
\ee\ supports a notification mechanism based on {\em Counter}s and {\em
Alarm}s.

A Counter is basically an integer value that can be incremented by $1$
``Tick'' using the primitive \reffun{CounterTick}. 

An Alarm is a notification that is attached to a specific Counter. The
link between a Counter and an Alarm is specified at compile time in
the OIL Configuration file.

An Alarm can be set to fire at a specified tick value using the
primitives \reffun{SetRelAlarm} and \reffun{SetAbsAlarm}. Alarms can
be set to be cyclically reactivated. Alarms can be canceled using the
primitive \reffun{CancelAlarm}.

When an Alarm fires, a notification takes place. A notification is set
to be one of the following actions:
\begin{description}
\item[Task activation.] In this case, a task is activated when the
  Alarm fires.
\item[Alarm callback.] In this case, an alarm callback (defined as
  \fn{void f(void)}) is called.
\end{description} 

The notifications are executed inside the \reffun{CounterTick}
function. It is up to the developer placing the counter in meaningful
places (e.g., a timer interrupt).

Counters, Alarms, and their notifications are specified inside the OIL
configuration file. 

\begin{warning}
Currently there is no support for automatically generated system
counters\index{System counters} (e.g., counters that are automatically
linked to hardware timers). All the counters have to be defined within
the OIL Configuration file, and the programmer have to call
\reffun{CounterTick} to increment them. 
\end{warning}

\pagebreak

\begin{function}{CounterTick}
  \synopsis{void CounterTick(CounterType c)}
  \begin{fundescription}
    This function receives a counter identifier as parameter, and it
    increments it by 1. This function is typically called inside an
    ISR type 2 or inside a task to notify that the event monitored by
    a counter has happened.
    
    The function also implements the notification of expired alarms,
    that is implemented, depending on the alarm configuration, as:
    \begin{itemize}
      \item an alarm callback function;
      \item a task activation.
    \end{itemize}

    The function is atomic, and no rescheduling will take place after
    the execution of this function. When called from the task level,
    to implement the rescheduling the application should call
    \reffun{Schedule} after the call to this
    function. When called from the ISR type 2 level, the rescheduling
    will automatically take place at the end of the interrupt routines.
  \end{fundescription}
  \begin{funparameters}
    \fpar{c}{The counter that needs to be incremented.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{The function does not return an error.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{GetAlarm}
  \synopsis{void GetAlarm (AlarmType AlarmID, TickRefType Tick)}
  \begin{fundescription}
    The system service GetAlarm returns the relative value in ticks
    before the alarm \vr{AlarmID} expires. \vr{AlarmID} {\em must} be
    in use. Allowed on task level, ISR, and in several hook routines.
  \end{fundescription}
  \begin{funparameters}
    \fpar{AlarmID}{Alarm identifier}
    \fpar{Tick}{(out) Relative value in ticks before the alarm expires}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{The function does not return an error.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{SetRelAlarm}
  \synopsis{void SetRelAlarm (AlarmType AlarmID, TickType increment, TickType cycle)}
  \begin{fundescription}
    After \vr{increment} ticks have elapsed, the \vr{AlarmID}
    notification is executed.
    
    If the relative value \vr{increment} is very small, the alarm may
    expire, and the notification can be executed before the system
    service returns to the user.  If \vr{cycle} is unequal zero, the
    alarm element is logged on again immediately after expiry with the
    relative value \vr{cycle}.
    
    The alarm \vr{AlarmID} must not already be in use: before changing
    the value of an alarm already in use, the alarm must be
    canceled. Allowed on task level and in ISR.
  \end{fundescription}
  \begin{funparameters}
    \fpar{AlarmID}{Reference to alarm}

    \fpar{increment}{Relative value in ticks representing the offset
      with respect to the current time of the first alarm expiration.}

    \fpar{cycle}{Cycle value in case of cyclic alarm. In case of
      single alarms, this parameter must be set to 0.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{The function does not return an error.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{SetAbsAlarm}
  \synopsis{void SetAbsAlarm (AlarmType AlarmID, TickType start, TickType cycle)}
  \begin{fundescription}
    The primitive occupies the alarm \vr{AlarmID} element. When
    \vr{start} ticks are reached, the \vr{AlarmID} notification is
    executed.
    
    If the absolute value \vr{start} is very close to the current
    counter value, the alarm may expire, and the task may become ready
    or the alarm-callback may be called before the system service
    returns to the user.
    
    If the absolute value \vr{start} was already reached before the
    system call, the alarm shall only expire when the absolute value
    \vr{start} is reached again, i.e. after the next overrun of the
    counter.
    
    If \vr{cycle} is unequal zero, the alarm element is logged on
    again immediately after expiry with the relative value \vr{cycle}.
    
    The alarm \vr{AlarmID} shall not already be in use: before
    changing the value of an alarm already in use, the alarm must be
    canceled.  Allowed on task level and in ISR.
  \end{fundescription}
  \begin{funparameters}
    \fpar{AlarmID}{reference to alarm.}

    \fpar{start}{Absolute value in ticks representing the time of the
      first expiration of the alarm.}

    \fpar{cycle}{cycle value in case of cyclic alarm. In case of
      single alarms, this parameter must be set to 0.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{The function does not return an error.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{CancelAlarm}
  \synopsis{void CancelAlarm (AlarmType AlarmID)}
  \begin{fundescription}
    The primitive cancels the alarm \vr{AlarmID}. Allowed on task
    level and in ISR.
  \end{fundescription}
  \begin{funparameters}
    \fpar{AlarmID}{reference to alarm}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{the function does not return an error.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF, FRSH
  \end{funconformance}
\end{function}

\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Counting Semaphores}

This section describes in detail the primitives provided by the
minimal API of \ee\ to support counting semaphores as a way to
implement mutual exclusion and synchronization between tasks.

A counting semaphore is a RTOS abstraction of an integer counter
coupled with a blocking queue. Basically two main operations are
possible on a semaphore, which are {\em waiting} on a semaphore, which
results in decrementing the counter if the counter has a value greater
than 0, or blocking the running task if the counter is 0, and {\em
posting} on a semaphore, which results in a counter increment if there
are no task blocked, or in the unblock of a blocked task otherwise.

\ee\ counting semaphores exports a simple interface which covers the
basic functionalities of a semaphore, like:
\begin{itemize}
\item Initializing a semaphore (\reffun{InitSem});
\item Waiting on a semaphore in a blocking
  (\reffun{WaitSem}) or non-blocking way (\reffun{TryWaitSem};
\item Posting on a semaphore (\reffun{PostSem});
\item Getting the value of a semaphore (\reffun{GetValueSem}).
\end{itemize}

Since waiting on a semaphore may result in blocking the running task,
the \reffun{WaitSem} primitive should be called only if the calling
task has a separate stack allocated to it (which means that \ee\ has
been configured as multistack).

Semaphores can also be allocated statically as a global variable,
which allow to bypass the call to \reffun{InitSem}.

Semaphores definition are not listed in the OIL file; semaphore
primitives receive as a parameter a pointer to the semaphore
descriptor.

\begin{warning}
Counting semaphores {\em do not} avoid Priority Inversion
problems. Please use Resources instead (see Section
\ref{sec:resource-primitives}).
\end{warning}

\begin{warning}
Counting semaphores are not implementef in the FRSH kernel.
\end{warning}

\pagebreak

\begin{function}{STATICSEM}
  \synopsis{SemType s = STATICSEM(value);}
  \begin{fundescription}
    This macro can be used to statically initialize a semaphore. It
    must be used inside the definition of a global semaphore variable
    to initialize a semaphore to a given value.
  \end{fundescription}
  \begin{funparameters}
    \fpar{value}{The counter value for the semaphore being initialized.}
  \end{funparameters}
  \begin{funreturn}
    \fret{none}{The function is a macro used at variable definition time.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{InitSem}
  \synopsis{void InitSem(SemType s, int value);}
  \begin{fundescription}
    This macro can be used to initialize a semaphore at runtime. It
    receives as a parameter the init value of the semaphore counter.
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{The semaphore being initialized.}
    \fpar{value}{The counter value for the semaphore being initialized.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{The function is a macro and it does not return an error.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{WaitSem}
  \synopsis{void WaitSem(SemRefType s);}
  \begin{fundescription}
    If the semaphore counter is greater than 0, then the counter is
    decremented by one. If the counter has a value of 0, then the
    calling (running) task blocks. A separate stack must be allocated
    to all the tasks which will call this primitive, because its
    execution may block the task.
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{The semaphore used by the primitive.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{The function does not return an error.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{TryWaitSem}
  \synopsis{int TryWaitSem(SemRefType s);}
  \begin{fundescription}
    This is a non-blocking version of \reffun{SemWait}. If the
    semaphore counter is greater than 0, then the counter is
    decremented by one, and the primitive returns 0. If the counter
    has a value of 0, then the counter is not decremented, and the
    primitive returns 1.
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{The semaphore used by the primitive.}
  \end{funparameters}
  \begin{funreturn}
    \fret{int}{0 if the semaphore counter has been decremented, 1 otherwise.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{PostSem}
  \synopsis{void PostSem(SemRefType s);}
  \begin{fundescription}
    This primitive unblocks a task eventually blocked on the
    semaphore. If there are no tasks blocked on the semaphore, then
    the semaphore counter is incremented by one.
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{The semaphore used by the primitive.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{The function does not return an error.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{GetValueSem}
  \synopsis{int GetValueSem(SemRefType s);}
  \begin{fundescription}
    If there are tasks blocked on the semaphore, the function returns
    \const{-1}; otherwise, this primitive returns the value of the
    semaphore counter.
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{The semaphore used by the primitive.}
  \end{funparameters}
  \begin{funreturn}
    \fret{int}{\const{-1} if there are tasks blocked on the semaphore,
      or the semaphore counter value otherwise.}
  \end{funreturn}
  \begin{funconformance}
    FP, EDF
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Time handling}
\label{sec:circulartimer}

The implementation of the EDF and FRSH scheduler done in the minimal
API is based on a timing reference which is made to be efficiently
implemented in small microcontrollers.

The traditional way of implementing a timing representation which can
be used to compute and store timing references used as example for
deadlines is based on the POSIX {\tt struct timespec} data
structure. Unfortunately, the {\tt struct timespec} data structure is
not suited to be implemented on small mirocontrollers. The structure
in fact is composed by two 32-bit integer representing seconds and
nanoseconds, which require a substantial code amount to implement the
most common operations.

For that reason, the EDF and FRSH implementation proposed by \ee\ uses
a relative notion of time. That is, the system proposes a timing
reference which has the same size of a hardware timer register. All
the timings are then considered relative to the current timing, and
the timings are ordered by using the sign of their difference.

The timing reference is often implemented using a hardware timer or
using a software incremented timer (e.g., like a software counter
incremented by a periodic interrupt).

Using this method it is possible to represent a set of deadlines which
has a maximum distance of half the wraparound time of the hardware or
software timer linked to them (see Figure \ref{fig:ictoh}).

\begin{figure}[htb]
\begin{center}
  \includegraphics[width=10cm]{images/ictoh.eps}
\end{center}
\caption{The relative timer representation. In the figure, $e_2$ comes before $e_3$}
\label{fig:ictoh}
\end{figure}

The approximation in general is quite good, because it allows to
handle the common cases of periodic tasks with deadline spanning from
a few milliseconds to hundreds of microseconds. with a relatively good
precision.




\pagebreak

\begin{function}{GetTime}
  \synopsis{TimeAbsType GetTime(void);}
  \begin{fundescription}
    This function is used to return the current system time.  This
    function is typically called inside a task, inside the main task
    or inside a ISR type 2.
  \end{fundescription}
  \begin{funreturn}
    \fret{TimeAbsType}{The current timer value.}
  \end{funreturn}
  \begin{funconformance}
    EDF, FRSH
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{System Startup}
When using the FP or EDF kernel, there is no need a specific startup
procedure. In particular, the kernel is already active after the first
instruction of the \fn{main} function. When using the FRSH kernel, the
function \reffun{frsh_init} must be used to initialize the resource
reservation and deadline checking features.

A typical application will be structured with application dependent
initialization routines inside the \fn{main} function. Then, tasks
will be activated with calls to \reffun{ActivateTask}, and finally the
\fn{main} task will end with a forever loop, implementing in this way
the background task.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{FRSH Kernel details}
\label{cha:frsh}

This brief Section is dedicated to the implementation of the FRESCOR
IST FP6 Project \cite{frescor} inside \ee. The Section start with an introduction of the FRESCOR Project, continuing with the description of the implemented FRSH API.

\section{Introduction to FRESCOR}

The FRESCOR project \cite{frescor} is aimed at developing a framework
that integrates advanced flexible scheduling techniques directly into
an embedded systems design methodology, covering all the levels
involved in the implementation, from the OS primitives, through the
middleware, up to the application level. This will be centred on a new
contract model that will specify which are the application
requirements with respect to the flexible use of the schedulable
resources in the system, and also what are the resources that must be
guaranteed if an application component is to be installed into the
system, and how the system can distribute any spare capacity that it
has, to achieve the highest usage of the available resources or to
optimise their usage while addressing energy constraints. The project
will build on the results of two previous EU projects: FIRST (Flexible
Integrated Real-Time Systems Technology) and OCERA (Open Components
for Embedded Real-time Applications).

The main objective of the project is to develop the enabling
technology and infrastructure required to effectively use the most
advanced techniques developed for real-time flexible scheduling in
embedded systems design methodologies and tools, providing the
necessary elements to target reconfigurable processing modules and
reconfigurable distributed architectures.

In the area of development methods for embedded applications with
complex timing requirements we have identified a large gap between the
research state of the art and the applicability. The project will be
addressed at closing this gap, and providing embedded systems
developers the engineering solutions to manage timing requirements at
a high level of abstraction, thus lowering the design and development
costs, and speeding up the time to market.  The project will address
the OS primitives needed to support the contract-based scheduling, the
development of middleware to support the contracts themselves and
adaptively manage the quality of service, the integration of this
infrastructure into a container framework for component-based
development methodologies, the development of simulation and analysis
tools, and the evaluation and exploitation of the results.


FRESCOR produced a framework capable of giving a system's view of the
timing requirements and the schedulable resources. The framework
enables the developer of an application component to focus on its own
timing requirements without having to focus on system-level issues,
which is essential in the dynamic scenario of reconfigurable
architectures. In addition, the framework will provide for a
transparent management of the quality of service at the system's
level, by providing an end-to-end distributed transaction manager,
adaptive system-level quality of service management middleware, and
system-level design and optimization methods.  The technologies
developed in the project will increase competitiveness of EU industry
by providing the proper abstractions that make it possible to handle
complex timing requirements in embedded applications, explicitly
supporting the integrated scheduling of reconfigurable resources,
including processors, reconfigurable hardware modules, memory, energy,
and networks.  

The implementation presented in this Section is the result of the
effort of Evidence in porting the FRESCOR scheduling API (named FRSH,
pronounced as ``fresh'') to \ee. The FRSH kernel basically adapt the
FRSH API as defined in the FRESCOR Project to a minimal environment
such as the one available on a microcontroller. The result is a kernel
configuration without support for dynamic reconfiguration with a ROM
footprint of around 10k for the complete system (more details on
\cite{frescor_ep7v2}).
 
Please note that the API implemented in the FRSH kernel is the merge
of two different APIs, one similar to the OSEK/VDX API, and one as a
subset of the FRSH API considering only the parts related to binding,
unbinding, and synchronization. This merge is still visible in the
primitive names, since the FRSH API derivative functions still have
the \const{frsh_} prefix\footnote{the naming of these functions will
be probably uniformed in the near future.}.

It is out of the scope of this document to explain in detail all the
caveats of the FRSH API. Instead, we will concentarte on the functions
implemented into \ee. The interested reader can find more information
on the following references: \cite{frescor}, \cite{frescor_ep7v2},
\cite{iris}.

\section{What is currently implemented of the FRSH API}

The implementation we presented on \ee\ is not a complete
implementation of the FRSH API. In particular, the implementation is a
tradeoff between functionality and performance, made in a way to
obtain a reasonable implementation on small microcontrollers.

The features which have been implemented are the following:
\begin{itemize}
\item Task activation, resources and alarms with API similar to the
  \const{FP} and \const{EDF} kernel;
\item Task binding and unbinding following the FRSH API specification;
\item Synchronization objects following the FRSH API specification.
\item IRIS \cite{iris} scheduling algorithm for resource reservations.
\item Support for the configuration using OIL and \rtd.
\item FRSH types implemented in a similar ways to the FRSH API.
\end{itemize}

For more information on the FRSH extensions on the OIL language
implemented by RT-Druid, you can refer to the \rtd\ reference manual.



\section{FRSH API - Task and VRES Statuses}

The following paragraphs describe Task and VRES statuses. Please note
that the status of a task is orthogonal to the status of a VRES. In
particular, the Task status controls the possibility for a task to
execute given its activations and suspensions on synchronizations. The
VRES status control the possibility for a task to be scheduled, which
is controlled by the budget and period assigned to the VRES in the
CONTRACT section of the OIL file.

\begin{constant}{Task States}
  \begin{constantdescription}
    This is the list of the task states a task can have during its life:
    \begin {lstlisting}
#define EE_TASK_SUSPENDED  0
#define EE_TASK_READY      1
#define EE_TASK_STACKED    2
#define EE_TASK_BLOCKED    4
#define EE_TASK_EXEC       8
#define EE_TASK_WASSTACKED 128
    \end{lstlisting}
    Task States in \ee\ are typically not visible to the application,
    because they are highly dependent on the particular \ee\ kernel
    implementation. In the \const{FRSH} kernel, the states have the
    following meaning: \const{EE_TASK_SUSPENDED} is used when a task
    is not requiring execution. \const{EE_TASK_READY} when a task is
    ready to execute and it is waiting that its VRES is active with
    the earliest deadline in the system to pass to the
    \const{EE_TASK_EXEC} status. \const{EE_TASK_STACKED} is used to
    track preempted tasks which are owning a
    Resource. \const{EE_TASK_BLOCKED} are used to track tasks which
    are blocked on synchronization objects. \const{EE_TASK_WASSTACKED}
    is used to track the fact that a task has been preempted or has
    been blocked still retaining its status on the stack.
  \end{constantdescription}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{constant}


\begin{constant}{VRES States}
  \begin{constantdescription}
    This is the list of the VRES states a task can have during its life:
    \begin {lstlisting}
#define EE_VRES_FREEZED    0
#define EE_VRES_INACTIVE   1
#define EE_VRES_ACTIVE     2
#define EE_VRES_RECHARGING 4
    \end{lstlisting}
    VRES states are not visible to the application, although they
    control the possibility for a task to be scheduled.  The possible
    states of a VRES are the following: \const{EE_VRES_INACTIVE} means
    that the VRES is linked to a task which has not been activated or
    which is blocked. When the task is activated, or when it wokes up
    from a synchronization, then the VRES is put in the
    \const{EE_VRES_ACTIVE} state, as specified by the IRIS \cite{iris}
    scheduling algorithm. When the task uses all its budget, the VRES
    is put in the state \const{EE_VRES_RECHARGING}. In this state, the
    task linked to the VRES cannot be executed, until the VRES
    recharging time happens. The VRES recharging time depends on the
    VRES budget, as well as on the idle times which may have the
    effect to anticipate the recharging instant. Due to the
    implementation of the circular timer, similar to what is done in
    the EDF kernel (see Section \ref{sec:circulartimer}), an inactive
    VRES may be put in the \const{EE_VRES_FREEZED} status when the
    deadline of an inactive VRES arrives in the past.
  \end{constantdescription}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{constant}





\subsection{FRSH API - Init and general functions}

\begin{function2}{frsh\_init}{frsh_init}
  \synopsis{int frsh_init(void);}
  \begin{fundescription}
    We cannot call any frsh functions before frsh\_init. After calling
    frsh\_init, the FRSH Kernel will be initialized.  The second time
    this function is called it fails.
  \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_SYSTEM_ALREADY_INITIALIZED}{FRSH Kernel already initialized.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_strerror}{frsh_strerror}
  \synopsis{int frsh_strerror(int error, char *message, size_t size);}
  \begin{fundescription}
    Converts a FRSH error code to a string.
  \end{fundescription}
   \begin{funparameters}
     \fpar{error}{The error code for which we want the description.}
     \fpar{message}{The error message.}
     \fpar{size}{The size of the buffer.}
   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{The error value is wrong.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_vres\_get\_contract}{frsh_vres_get_contract}
  \synopsis{int frsh_vres_get_contract (const frsh_vres_id_t vres, frsh_contract_t *contract)}
  \begin{fundescription}
    This operation stores the contract parameters currently associated
    with the specified vres in the variable pointed to by contract. It
    returns an error if the vres\_id is not recognised.
  \end{fundescription}
   \begin{funparameters}
     \fpar{vres}{the VRES}
     \fpar{contract}{the pointer to the contract object}
   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors} 
    \fret{FRSH_ERR_BAD_ARGUMENT}{If the contract argument is NULL or the value of the vres argument is not in range.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}


\begin{function2}{frsh\_contract\_get\_basic\_params}{frsh_contract_get_basic_params}
  \synopsis{int frsh_contract_get_basic_params (const frsh_contract_t *contract,}\\
  \lstinline!                                        frsh_rel_time_t *budget_min,!\\
  \lstinline!                                        frsh_rel_time_t *period_max,!\\
  \lstinline!                                        frsh_workload_t *workload,!\\
  \lstinline!                                        frsh_contract_type_t *contract_type);!\\
  \begin{fundescription}
    This operation obtains from the specified contract object its
    budget, period, and workload, and copies them to the places
    pointed to by the corresponding output parameters.
  \end{fundescription}
   \begin{funparameters}
     \fpar{contract}{the pointer to the contract object}
     \fpar{budget_min}{pointer to preallocated space}
     \fpar{period_max}{pointer to preallocated space}
     \fpar{workload}{pointer to preallocated space}
     \fpar{contract_type}{pointer to preallocated space}
   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{Some of the parameters are NULL.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_contract\_get\_timing\_reqs}{frsh_contract_get_timing_reqs}
  \synopsis{int frsh_contract_get_timing_reqs(const frsh_contract_t *contract, }\\
\lstinline!				      int *d_equals_t,!\\
\lstinline!				      frsh_rel_time_t *deadline, !\\
\lstinline!				      frsh_signal_t *budget_overrun_signal, !\\
\lstinline!				      frsh_signal_info_t *budget_overrun_siginfo, !\\
\lstinline!				      frsh_signal_t *deadline_miss_signal, !\\
\lstinline!				      frsh_signal_info_t *deadline_miss_siginfo);!\\
  \begin{fundescription}
    The operation obtains the corresponding input parameters from the
    specified contract object. This function has been implemented only
    for compatibility with the FRSH API. It returns that Deadline is
    equal to the period, and there are no signals defined.
  \end{fundescription}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{If the contract is NULL.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_thread\_get\_vres\_id}{frsh_thread_get_vres_id}
  \synopsis{int frsh_thread_get_vres_id(const frsh_thread_id_t thread, frsh_vres_id_t *vres_id);}
  \begin{fundescription}
    This operation stores the Id of the vres associated with the
    specified thread in the variable pointed to by vres. It returns an
    error if the thread does not exist, it is not under the control of
    the scheduling framework, or is not bound.
  \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_NOT_BOUND}{If the given thread does not have a valid vres bound to it.}
    \fret{FRSH_ERR_BAD_ARGUMENT}{If the given thread does not exist or the vres argument is NULL.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_contract\_get\_basic\_params}{frsh_contract_get_basic_params}
  \synopsis{int frsh_contract_get_basic_params (const frsh_contract_t *contract, }\\
\lstinline!				        frsh_rel_time_t *budget_min,!\\
\lstinline!				        frsh_rel_time_t *period_max,!\\
\lstinline!				        frsh_workload_t *workload,!\\
\lstinline!				        frsh_contract_type_t *contract_type);!\\
  \begin{fundescription}
    This operation obtains from the specified contract object its
    budget, period, and workload, and copies them to the places
    pointed to by the corresponding output parameters
  \end{fundescription}
  \begin{funparameters}
     \fpar{contract}{the pointer to the contract object}
     \fpar{budget_min}{pointer to preallocated space}
     \fpar{period_max}{pointer to preallocated space}
     \fpar{workload}{pointer to preallocated space}
     \fpar{contract_type}{pointer to preallocated space}
   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{if one of the contract or pointers is NULL.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_config\_is\_admission\_test\_enabled}{frsh_config_is_admission_test_enabled}
  \synopsis{bool frsh_config_is_admission_test_enabled(void)}
  \begin{fundescription}
    Always returns 0.
  \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
%%  \begin{funreturn}
%%    \fret{int}{The current timer value.}
%%  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_vres\_get\_remaining\_budget}{frsh_vres_get_remaining_budget}
  \synopsis{int frsh_vres_get_remaining_budget (const frsh_vres_id_t vres, frsh_rel_time_t *budget);}
  \begin{fundescription}
    This function stores in the variable pointed to by budget the
    remaining execution-time budget associated with the specified
    vres.
  \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{If the value of the vres argument is not in range or budget is NULL.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_vres\_get\_usage}{frsh_vres_get_usage}
  \synopsis{int frsh_vres_get_usage (const frsh_vres_id_t vres, frsh_rel_time_t *spent)}
  \begin{fundescription}
    This function stores the current execution time spent by the
    threads bound to the specified vres in the variable pointed to by
    cpu\_time.
  \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{if the value of the vres argument is not in range or spent is NULL.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_vres\_get\_budget\_and\_period}{frsh_vres_get_budget_and_period}
  \synopsis{int frsh_vres_get_budget_and_period (const frsh_vres_id_t vres, }\\
\lstinline!				         frsh_rel_time_t *budget,!\\
\lstinline!				         frsh_rel_time_t *period);!\\
  \begin{fundescription}
    This function stores in the variables pointed to by budget and
    period, the execution-time budget and the period respectively
    associated with the specified vres. If any of these pointers is
    NULL, the corresponding information is not stored.
  \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{if the value of the vres argument is
      not in range, or budget and period are both NULL.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}


\section{FRSH API - Binding and unbinding}


\begin{function2}{frsh\_thread\_bind}{frsh_thread_bind}
  \synopsis{int frsh_thread_bind(const frsh_vres_id_t vres, const frsh_thread_id_t thread)}
  \begin{fundescription}
    This operation associates a thread with a vres, which means that
    it starts consuming the vres's budget and is executed according to
    the contract established for that vres. If the thread is already
    bound to another vres, it is effectively unbound from it and bound
    to the specified one.

    It fails if there is already a thread bound to this vres.
  \end{fundescription}
  \begin{funparameters}
    \fpar{vres}{the vres to bind to the task}
    \fpar{thread}{the thread to which we have to bind the vres}
  \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{if the vres value does not complain
      with the expected format or valid range or the given thread does
      not exist.}
    \fret{FRSH_ERR_NOT_CONTRACTED_VRES}{if the referenced vres is not valid}
    \fret{FRSH_ERR_ALREADY_BOUND}{if the given vres has a thread already bound}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_thread\_unbind}{frsh_thread_unbind}
  \synopsis{int frsh_thread_unbind(const frsh_thread_id_t thread);}
  \begin{fundescription}
    This operation unbinds a thread from a vres. Since threads with no
    vres associated are not allowed to execute, they remain in a
    dormant state until they are either eliminated or bound again.

    If the thread is inside a critical section the effects of this
    call are deferred until the critical section is ended
  \end{fundescription}
   \begin{funparameters}
     \fpar{thread}{The thread to be unbinded}
   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{if the given thread does not exist.}
    \fret{FRSH_ERR_NOT_BOUND}{if the given thread does not have a valid vres bound to it}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}


\section{FRSH API - Synchronization objects}

\begin{function2}{frsh\_synchobj\_signal}{frsh_synchobj_signal}
  \synopsis{int frsh_synchobj_signal(const frsh_synchobj_handle_t synch_handle);}
  \begin{fundescription}
    This function sends a notification event to the synchronization
    object specified as parameter. If there is at least one vres
    waiting on the synchronization object, it is awaken. If more than
    one vres are waiting, just one of them is awaken. If no vres is
    waiting on the synchronization object, the notification event is
    queued.
  \end{fundescription}
  \begin{funparameters}
    \fpar{synch_handle}{The synchronisation object.}
  \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{if synch\_handle is 0.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}


\begin{function2}{frsh\_synchobj\_wait}{frsh_synchobj_wait}
  \synopsis{int frsh_synchobj_wait (const frsh_synchobj_handle_t synch_handle,}\\
\lstinline!                           frsh_rel_time_t *next_budget,!\\
\lstinline!                           frsh_rel_time_t *next_period,!\\
\lstinline!                           bool *was_deadline_missed, !\\
\lstinline!                           bool *was_budget_overran);!\\
  \begin{fundescription}
    This operation is invoked by threads to indicate that a job has
    been completed (and that the scheduler may reassign the unused
    capacity of the current job to other vres). This implementation de
    facto does not void the budget, but simply blocks the the task. In
    fact, the IRIS \cite{iris} scheduler automatically reclaims unused
    bandwidth.

    As a difference with \reffun{frsh_timed_wait}, here the vres
    specifies to be awakened by the arrival of a signal operation
    instead of at a precise point of time.

    The vres' budget will be made zero for the remainder of the vres'
    period, and FRSH will not replenish it until an event has been
    notified to the synchronisation object by another vres.  It can
    happen that the synchronisation object has notification events
    queued from the past, in this case one of the events is dequeued
    immediately and the vres won't have to wait for another one.

    At the time of reception of a notification event (wether in the
    future or in the past), all pending budget replenishments (if any)
    are made effective. Once the vres has a positive budget and the
    scheduler schedules the calling thread again, the call returns and
    the vres continues executing.  Except for those parameters equal
    to NULL pointers, the system reports the current period and budget
    for the current job, it informs if the deadline of the previous
    job was missed or not, and whether the budget of the previous job
    was overrun or not. Note: this implementation using the IRIS
    scheduler returns the VRES period and budget (which may not be in
    sync with budget and periods of the task). For the same reason,
    since there is not a direct link of the budget/period of a vres
    with the task deadline, the deadline miss and budget overrun
    information are not provided (in other words, they are meaningless
    in this implementation).
  \end{fundescription}
   \begin{funparameters}
     \fpar{synch_handle}{Synchronisation object upon which the vres will be waiting.}
     \fpar{next_budget}{Upon return of this function, the variable pointed
                     by this function will be equal to the current vres
                     budget. If this parameter is set to NULL, no action is
                     taken}
     \fpar{next_period}{The vres period upon return (ignored if NULL).}
     \fpar{was_deadline_missed}{NOT IMPLEMENTED}
     \fpar{was_budget_overran}{NOT IMPLEMENTED}
   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{if synch\_handle is 0.}
    \fret{FRSH_ERR_INTERNAL_ERROR}{if the task still uses a resource.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}

\begin{function2}{frsh\_synchobj\_wait\_with\_timeout}{frsh_synchobj_wait_with_timeout}
  \synopsis{int frsh_synchobj_wait_with_timeout (const frsh_synchobj_handle_t synch_handle, }\\
\lstinline!			 		 const frsh_abs_time_t *abs_timeout,!\\
\lstinline!				 	 bool *timed_out,!\\
\lstinline!					 frsh_rel_time_t *next_budget,!\\
\lstinline!					 frsh_rel_time_t *next_period,!\\
\lstinline!					 bool *was_deadline_missed,!\\
\lstinline!					 bool *was_budget_overran);!\\
  \begin{fundescription}
    This call is the same as \reffun{frsh_synchobj_wait} but with an
    extra absolute timeout. The timed\_out argument, indicates whether
    the function returned because of the expiration of the timeout or
    not.
  \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{if synch\_handle is 0 or the abs\_timeout argument is NULL or its value is in the past.}
    \fret{FRSH_ERR_INTERNAL_ERROR}{if the task still uses a resource.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}


\begin{function2}{frsh\_timed\_wait}{frsh_timed_wait}
  \synopsis{int frsh_timed_wait (const frsh_abs_time_t *abs_time, }\\
\lstinline!                        frsh_rel_time_t *next_budget, !\\
\lstinline!                        frsh_rel_time_t *next_period, !\\
\lstinline!                        bool *was_deadline_missed, !\\
\lstinline!                        bool *was_budget_overran);!\\
  \begin{fundescription}
    This operation is invoked by threads associated with bounded
    workload vres to indicate that a job has been completed (and that
    the scheduler may reassign the unused capacity of the current job
    to other vres). It is also invoked when the first job of such
    threads has to be scheduled.

    As an effect, the system will make the current vres's budget zero
    for the remainder of the vres's period, and will not replenish the
    budget until the specified absolute time. At that time, all
    pending budget replenishments (if any) are made effective. Once
    the vres has a positive budget and the scheduler schedules the
    calling thread again, the call returns and at that time, except
    for those parameters equal to NULL pointers, the system reports
    the current period and budget for the current job, whether the
    deadline of the previous job was missed or not, and whether the
    budget of the previous job was overrun or not.

    Note about this implementation: The same exceptions to this
    description made for the \reffun{frsh_synchobj_wait} applies.
  \end{fundescription}
  \begin{funparameters}
    \fpar{abs_time}{absolute time at which the budget will be replenished}

    \fpar{next_budget}{upon return of this function, the variable
      pointed by this function will be equal to the current vres
      budget. If this parameter is set to NULL, no action is taken.}

    \fpar{next_period}{upon return of this function, the variable
      pointed by this function will be equal to the current vres
      period. If this parameter is set to NULL, no action is taken.}

    \fpar{was_deadline_missed}{upon return of this function, the
      variable pointed by this function will be equal to true if the
      previous vres deadline was missed, to false otherwise. If this
      parameter is set to NULL, no action is taken.}

    \fpar{was_budget_overrun}{upon return of this function, the
      variable pointed by this function will be equal to true if the
      previous vres budget was overrun, to false otherwise. If this
      parameter is set to NULL, no action is taken.}

  \end{funparameters}
  \begin{funreturn}
    \fret{FRSH_NO_ERROR}{No errors}
    \fret{FRSH_ERR_BAD_ARGUMENT}{if abs\_time is NULL.}
  \end{funreturn}
  \begin{funconformance}
    FRSH
  \end{funconformance}
\end{function2}


