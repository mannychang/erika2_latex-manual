\chapter{API reference}
\label{sec:api_reference}

\section{Introduzione}

Il sistema operativo \ee\ fornisce una interfaccia semplice per 
l'esecuzione di applicazioni concorrenti su sistemi a singolo processore.

L'intefraccia proposta e' adatta per piccoli microcontrollori da 8 a 32 
bit. L'architettura prevede che i task possano essere eseguiti 
concorrentemente, con la possibilita' di scambiare informazioni attraverso
il meccanismo della memoria condivisa.

I task, in \ee, sono schedulati secondo priorita' fisse, e viene utilizzato
il protocollo Immediate Priority Ceiling per la condivisione di risorse.

Gli interrupt hanno sempre priorita' maggiore rispetto ai task applicativi,
in modo da favorire l'esecuzione le attivita' richieste dalle periferiche.
Gli interrupt, o Interrupt Service Routines, possono essere di due tipi: 
{\em ISR Type 1} and {\em ISR Type 2}. La Sezione 
\ref{sec:interrupt_primitives} e' dedicata esplicitamente alla descrizione
della gestione di interruzioni in \ee.

\subsection{Classi di conformance}

La API minimale di \ee\ non supporta diversi tipi di classi di conformance. La sola
configurazione supportata dal sistema e' FP (Fixed Priority), che ha un
funzionamento simile a quello delle classi di conformance BCC1 e BCC2 di
\ee, in base al fatto che il kernel sia configurato in monostack oppure in
multistack.

La classe di conformance FP e' supportata dal multithreading a priorita'
fissa, con uno o piu' task per ciascuna priorita' e con una o piu'
attivazione pendente per ciascun task.

\subsection{Primitive disponibili}

\ee\ fornisce un insieme di primitive  che possono essere chiamate in 
differenti contesti. La lista completa delle primitive e' presentata in
Tabella \ref{tab:api-restrictions}, insieme alle indicazioni dei contesti
nei quali e' possibile chiamare ciascuna funzione.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INIZIO PARTE IMPORTATA DA TabellaOSEK.lyx - NON MODIFICARE
% MODIFICATE IL LYX, ESPORTATE e commentate all'inizio ed alla fine!!!
\input{tabellaosek.tex}
% FINE PARTE IMPORTATA DA TABELLAOSEK.LYX - NON MODIFICARE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





%% 
%% Basic template 
%%
%% \begin{function}{FunctionName}
%% \synopsis{}
%%   \begin{fundescription}
%%   \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
%%   \begin{funreturn}
%%   \fret{}{}
%%   \fret{}{(Extended)}.
%%   \end{funreturn}
%%   \begin{funconformance}
%%     BCC1, BCC2, ECC1, ECC2
%%   \end{funconformance}
%% \end{function}


\pagebreak

\section{Costanti}
\label{sec:constants}

Di seguito e' riportata una lista delle costanti fornite in \ee\ e disponibili 
dello sviluppatore per la scrittura delle applicazioni.

\begin{constant2}{INVALID\_TASK}{INVALID_TASK}
  \begin{constantdescription}
    Questa costante rappresenta l'ID di task invalido.
  \end{constantdescription}
\end{constant2}

\begin{constant2}{EE\_MAX\_NACT}{EE_MAX_NACT}
  \begin{constantdescription}
    Questa costante rappresenta il massimo numero di attivazioni pendenti che possono 
	essere gestite per ciascun task. Il valore di default per questa costante e' il
	massimo valore disponibile per un unsigned integer dell'architettura specifica.
  \end{constantdescription}
\end{constant2}

\begin{constant2}{RES\_SCHEDULER}{RES_SCHEDULER}
  \begin{constantdescription}
    Questo e' l'ID della risorsa \const{RES_SCHEDULER}.

	La risorsa e' disponibile solo quando \const{USE_RESSCHEDULER} e' impostato al 
	valore \const{TRUE} all'interno del file di configurazione OIL. La costante 
	\const{RES_SCHEDULER}, che identifica il ceiling di sistema, dipende dai task
	che sono stati creati creati, ed e' calcolata quando \rtd\ genera il codice
	di configurazione per \ee.
  \end{constantdescription}
\end{constant2}

\begin{constant}{Stato di un task}
  \begin{constantdescription}
    Di seguito e' riportata la lista degli stati che un task puo' assumere
	durante l'esecuzione del sistema:
    \begin {lstlisting}
#define EE_READY      1
#define EE_STACKED    2
#define EE_BLOCKED    4
#define EE_WASSTACKED 8
    \end{lstlisting}
	
	GLi stati di un task in \ee\ sono tipicamente non visibili dal 
	programmatore, in quanto sono altamente dipendenti dalla particolare
	configurazione del sistema. In particolare, quando viene usata una
	configurazione monostack, gli stati dei task sono rimossi dalla memoria
	per risparmiare RAM. Lo stato \const{EE_READY} caratterizza un task il
	quale e' pronto per l'esecuzione ma per il quale non e' ancora stato 
	allocato lo stack. Lo stato \const{EE_STACKED} si riferisce a un task
	che puo' essere o il task in esecuzione oppure il task che ha subito
	preemption sullo stack. Lo stato \const{EE_BLOCKED} identifica un task
	che e' stato eseguito e che attualmente e' bloccato da una primitiva di
	sincronizzazione (per esempio, dalla primitiva \reffun{WaitSem}).
	Un flag addizionale, \const{EE_WASSTACKED}, e' definito per utilizzi
	interni, allo scopo di mappare un task ready che e' stato risvegliato
	da una primitiva di sincronizzazione ma che si trova ancora nella coda
	dei task ready, in attesa di essere eseguito.
  \end{constantdescription}
\end{constant}

%% Nota: questa parte non è ancora generata da RT-Druid!

%% \begin{constant}{xxxx}
%% \nb{Nell'oil un 'counter' deve essere definito come segue

%% COUNTER Counter1 {
%%     MINCYCLE = 1;
%%     MAXALLOWEDVALUE = 16;
%%     TICKSPERBASE = 2;
%% };

%% quindi, con un MINCYCLE, MAXALLOWEDVALUE e TICKPERBASE, che sono anche i valori qui indicati;
%% Pero' questi NON vengono dichiarati nel codice usando delle define, ma inserendone i valori nel vettore

%%     const EE_oo_counter_ROM_type EE_counter_ROM[] = {
%%         {16, 2, 1}         /*Counter1*/
%%     };

%% Mi sembra che torni con quanto indicato su ee/pkg/kernel/oo/inc/ee_common.h

%% Mentre, di TICKDURATION ... NON so nulla : e' la prima volta che lo vedo (forse c'era qualcosa nella primissima versione con H8).

%% Altra cosa: non mi sembra esista un 'counter di sistema'.
%% }
%% \begin {lstlisting}
%% /* these #defines have to be defined by the user or by the HAL!!!
%%    x is the counter */

%% /* Maximum possible allowed value of counter x in ticks. */
%% //#define OSMAXALLOWEDVALUE_x 

%% /* Number of ticks required to reach a specific unit of counter x. */
%% //#define OSTICKSPERBASE_x 
%% /* Minimum allowed number of ticks for a cyclic alarm of counter x. */
%% //#define OSMINCYCLE_x 
%% /* Maximum possible allowed value of the system counter in ticks. */
%% //#define OSMAXALLOWEDVALUE 
%% /* Number of ticks required to reach a specific unit of the system counter. */
%% //#define OSTICKSPERBASE 
%% /* Minimum allowed number of ticks for a cyclic alarm of the system counter. */
%% //#define OSMINCYCLE 

%% /* Duration of a tick of the system counter in nanoseconds. */
%% //#define OSTICKDURATION
%% \end{lstlisting}
%% \end{constant}


\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Tipi di dato}
\label{sec:types}

Questa sezione contiene la descrizione dei tipi dei dati utilizzati da \ee.
Quando la dimensione di un determinato tipo di dato e' indicata come pari
alla dimensione dei registri macchina, si intende che tale tipo ha la
dimensione dei registri general purpose della specifica CPU.

\begin{type}{AlarmType}
  \begin{typedescription}
    Questo tipo di dati (signed) e' utilizzato per memorizzare gli ID
	degli allarmi. Ha la dimensione di un registro.
  \end{typedescription}
\end{type}

\begin{type}{CounterType}
  \begin{typedescription}
    Questo tipo di dato (signed) e' usato per memorizzare gli ID dei 
	contatori. Ha la dimensione di un registro.
  \end{typedescription}
\end{type}

\begin{type}{ResourceType}
  \begin{typedescription}
    Questo tipo di dato (unsigned) e' utilizzato per memorizzare l'ID 
	delle risorse. Ha la dimensione del registro.
  \end{typedescription}
\end{type}

\begin{type}{SemType}
  \begin{typedescription}
    Questo tipo di dato e' una struttura che serve a memorizzare le
	informazioni relative a un semaforo di conteggio.
  \end{typedescription}
\end{type}

%% /toOl: QUAAAAAAAAAAAAAAAAAA!!!!

\begin{type}{SemRefType}
  \begin{typedescription}
    Questo e' un puntatore a \reftype{SemType}.
  \end{typedescription}
\end{type}

\begin{type}{TaskType}
  \begin{typedescription}
    Questo tipo di dati (signed) e' usato per memorizzare il Task ID, e ha la dimensione di un registro.
  \end{typedescription}
\end{type}

\begin{type}{TickType}
  \begin{typedescription}
    Questo tipo di dato (unsigned) e' usato per memorizzare il valore dei Counter Ticks, e ha la dimensione di un registro.
  \end{typedescription}
\end{type}

\begin{type}{TickRefType}
  \begin{typedescription}
    Questo e' un puntatore a un tipo di dati  \reftype{TickType}.
  \end{typedescription}
\end{type}

\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Definizione degli oggetti}
Le seguenti macro devono essere usate quando viene definito un Task.

\begin{function_nopb}{TASK}
  %PJ: da ricontrollare come è scritta
  \synopsis{TASK(Funcname) \{...\}}
  
  \begin{fundescription}
    La keyword TASK deve essere usata quando viene dichiarata una funzione TASK.
  \end{fundescription}
  
  \begin{funconformance}
    BCC1, BCC2, ECC1, ECC2
  \end{funconformance}
\end{function_nopb}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%









\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Primitive per la gestione di Task}

La API minimale di \ee\ supporta la definizione di task che sono assimilabili ai Basic
Task dello standard OSEK/VDX.

I task in \ee\ sono tipicamente implementati nella forma di normali funzioni C, che eseguono il relativo codice e poi terminano.
Ciascuna di tali esecuzioni e' chiamata {\em Istanza del task}\index{Istanza del task}. Al termine di un task basic, lo stack relativo al task viene liberato.
I task \ee\ tipicamente non si bloccano, ed in questo modo permettono allo sviluppatore di implementare la condivisione dello stack tra diversi task. 
La condivisione dello stack permette allo sviluppatore di ridurre l'utilizzo di memoria RAM da parte del programma.

Il supporto per primitive bloccanti come semafori di conteggio e' disponibile anche se il kernel e' configurato in modalita' multistack, nel caso di task ai quali e' stato assegnato uno stack privato. I task che utilizzano primitive bloccanti sono tipicamente implementati nella forma di task che senza terminazione, nei quali ciascuna istanza del task termina con una istruzione di sincronizzazione costituita, per esempio, da una chiamata alla wait su semaforo.

La politica di scheduling utilizzata in \ee\ e' la cosiddetta Fixed Priority Scheduling con Immediate Priority Ceiling and Preemption Thresholds. Questo permette di implementare la seguente tipologia di task:
\begin{description}
\item[Full Preemptive Task] Un task Full Preemptive e' un task che puo' essere interrotto in qualsiasi istante dai task a priorita' piu' elevata.
\item[Non Preemptive Task] Un task di tipo Non Preemptive e' assimilabile ad un task di tipo Full
  Preemptive che esegue per tutta la sua durata bloccando una risorsa e avendo il relativo ceiling pari alla massima priorita' del sistema. Questo fatto fa' si che il task Non Preemptive non possa essere interrotto da nessun altro task, ma solo da eventuali interrupt.
\item[Mixed Preemptive Task] Un task di tipo Mixed Preemptive e' un task che viene eseguito ad una priorita' pari ad una priorita' maggiore della priorita' alla quale il task viene inserito nella ready queue (Questa tecnica e' chiamata {\em Preemption Thresholds}).  In tal modo il numero di preemption puo' essere ridotto considerevolmente, cosa che permette di risparmiare una gran quantita' di memoria RAM.
\end{description}

I task vengono attivati per mezzo della primitiva \reffun{ActivateTask}. Attivare un task significa che il task che viene attivato puo' essere schedulato per l'esecuzione, e che quindi puo' eseguire una istanza. Una attivazione di task mentre il task e' gia' in esecuzione oppure mentre si trova nella ready queue, ovvero in attesa di essere eseguito, viene salvata come attivazione pendente. Il numero massimo di attivazioni pendenti e' dipendente dall'implementazione.

I task della API minimale di in \ee\ sono leggermente diversi dai task utilizzati nelle conformance classes simili a OSEK. Le principali differenze sono le seguenti:
\begin{itemize}
\item La API minimale non supporta le primitive \fn{TerminateTask} e \fn{ChainTask}.
\item Il numero di attivazioni pendenti non necessita di essere specificato all'interno di un file OIL, come invece avviene per le classi di conformance BCC2 and ECC2 in \ee.
\end{itemize}


\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{ActivateTask}
  \synopsis{void ActivateTask(TaskType TaskID);}
  
  \begin{fundescription}
    Questa primitiva attiva il task identificato da \vr{TaskID}. Dopo l'attivazione il task puo' diventare il task running se esso ha la priorita' piu' elevata rispetto agli altri task presenti nella ready queue.

    Una volta attivato, il task esegue una istanza, che inizia con la prima istruzione della funzione che implementa il codice del task. Se il task viene attivato quando una sua istanza e' gia' in esecuzione, o mentre si trova nella ready queue, l'attivazione viene salvata come attivazione pendente, che verra' gestita successivamente. Se la nuova attivazione pendente fa si che il numero di attivazioni pendenti diviene superiore al numero massimo impostato in fase di implementazione, la richiesta di attivazione viene ignorata.

    La funzione puo' essere chiamata dal Background task, che tipicamente e' costituito dalla funzione \fn{main()}.

  \end{fundescription}
  
  \begin{funparameters}
    \fpar{TaskID}{Task reference.}
  \end{funparameters}
  
  \begin{funreturn}
    \fret{void}{La funzione non ritorna alcun codice di errore.}
  \end{funreturn}
  
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{Schedule}
  \synopsis{void Schedule(void)}
  \begin{fundescription}
    Questa primitiva puo' essere utilizzata come punto di ri-schedulazione per i task che utilizzano le Preemption Thresholds e per i task di tipo Non Preemptive.

    Quando questa primitiva viene invocata, un task che utilizzi la preemption threshold imposta la propria priorita' al valore piu' basso usato per l'inserimento nella ready queue. A questo punto, il sistema controlla se esistono task a priorita' piu' elevata che hanno diritto di fare preemption, nel qual caso la preemption viene effettuata. Nel momento in cui la primitiva ritorna, i task che utilizzano la preemption threshold ritorneranno ad acquisire la loro priorita' di threshold.
    
    La primitiva non ha effetto se il task chiamante non e' un task di tipo Non Preemptive ne' un task che usa la preemption thresholds.
  \end{fundescription}
  \begin{funreturn}
    \fret{void}{La funzione non ritorna alcun valore.}  
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Primitive di gestione delle risorse}
\label{sec:resource-primitives}
Il termine risorsa viene utilizzato da \ee\ per identificare i semafori binari che servono ad implementare le sezioni critiche condivise.

Le risorse sono implementate utilizzando il protocollo Immediate Priority Ceiling. 
%
%
% \nb{mettere link alla sezione di Peppe}
%
%
Una risorsa viene bloccata (locked) utilizzando la primitiva \reffun{GetResource}, e sbloccata utilizzando \reffun{ReleaseResource}.

Esiste anche il supporto per una risorsa speciale chiamata \refconst{RES_SCHEDULER}. La risorsa \refconst{RES_SCHEDULER} ha un ceiling pari alla piu' elevata priorita' nel sistema. Un task che blocca la risorsa \refconst{RES_SCHEDULER} diviene non-preemptabile. Se necessaria, la risorsa \refconst{RES_SCHEDULER} deve essere impostata all'interno del file di configurazione OIL.

\pagebreak


\begin{function}{GetResource}
  \synopsis{void GetResource (ResourceType ResID)}
  \begin{fundescription}
    Questa primitiva puo' essere usata per implementare una sezione critica controllata dalla risorsa indicata da \vr{ResID}. La sezione critica viene quindi terminata da una chiamata a \reffun{ReleaseResource}.

    E' permesso l'annidamento di sezioni critiche controllate da diverse risorse.

    La chiamata a \reffun{Schedule} non e' permessa all'interno di una sezione critica.

    Il servizion puo' essere chiamato solo dal livello task.
  \end{fundescription}
  \begin{funparameters}
    \fpar{ResID}{Riferimento a risorsa}
  \end{funparameters}
  \begin{funreturn}
    \fret{void} {La funzione non ritorna alcun valore.} 
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{ReleaseResource}
  \synopsis{void ReleaseResource (ResourceType ResID)}
  \begin{fundescription}
    \fn{ReleaseResource} e' utilizzata per rilasciare precedentemente bloccata da una chiamata \reffun{GetResource}, e che quindi chiude la sezione critica.
    
    Per informazioni su sezioni critiche annidate, si veda \reffun{GetResource}.
    Il servizio puo' essere chiamato dal solo livello dei task.
  \end{fundescription}
  \begin{funparameters}
    \fpar{ResID}{Identificatore di risorsa}
  \end{funparameters}
  \begin{funreturn}
    \fret{void} {La funzione non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

\pagebreak



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Primitive di gestione degli interrupt}
\label{sec:interrupt_primitives}

\ee\ supporta la gestione degli interrupt, che vengono modellizzati considerando il tipico design dei controllori degli interrupt dei microcontrollori, che utilizzano un assegnamento prioritario delle sorgenti di interrupt.

Per soddisfare i requisiti nella gestione di routine di interrupt veloci, \ee\ supporta la definizione di cosiddetti fast interrupts handlers chiamati {\em ISR Type 1}. Questi permettono di gestire interruzioni nel modo piu' veloce possibile, ma per contro limitano la possibilita' di chiamare servizi di sistema all'interno del codice del fast handler.

Per questo motivo e' prevista la possibilita' di utilizzare i cosiddettid {\em ISR Type 2}, che possono essere usati - per esempio - per l'implementazione di timer hardware, dal momento che permettono la chiamata di primitive di sistema. Per contro, essi sono piu' lenti degli ISR Type 1 a causa dell'overhead introdotto dal sistema per l'implementazione della preemption.

Molti dettagli implementativi relativi alla gestione degli interrupt dipende fortemente dalla particolare architettura del microcontrollore sul quale \ee\ viene utilizzato. Si faccia riferimento alla documentazione relativa al porting di \ee\ su una specifica architettura per maggiori dettagli.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Primitive Counter e Alarms }
\ee\ supporta un meccanismo di notifica basato su {\em Counter}s e {\em
Alarm}s.

Un Counter e' semplicemente un valore integer che viene incrementato di $1$
``Tick'' utilizzando la primitiva \reffun{CounterTick}. 

Un Alarm e' una notifica che viene collegata ad uno specifico Counter. Il 
collegamento tra il Counter e l'Alarm viene specificato al momento della 
compilazione all'interno del file di configurazione OIL.

Un Alarm puo' essere impostato per essere generato ad uno specifico valore 
di tick utilizzando le primitive \reffun{SetRelAlarm} e \reffun{SetAbsAlarm}. 
Gli Alarms possono essere impostati per essere riattivati periodicamente. 
Gli Alarms possono essere cancellati per mezzo della primitiva 
\reffun{CancelAlarm}.

Quando un Alarm viene attivato, ha luogo una notifica. La notifica puo' essere
impostata per effettuare una delle seguenti azioni:
\begin{description}
\item[Task activation.] In questo caso viene attivato un task quando il 
 corrispondente Alarm viene generato.
\item[Alarm callback.] In questo caso viene chiamata una alarm callback (definita 
 come \fn{void f(void)}).
\end{description} 

Le notifiche vengono eseguite all'interno della funzione \reffun{CounterTick}. 
E' compito dello sviluppatore posizionare il contatore in un punto signiticativo
del programma (per esempio, all'interno di una routine di timer interrupt).

I Counters, gli Alarms e le relative azioni di notifica sono specificate all'interno
del file di configurazione OIL. 

\begin{warning}
Al momento non c'e' il supporto per Timers che sono automaticamente aggiornati dal 
sistema (per esempio, contatori che sono collegati ai timer hardware). Tutti i contatori
devono essere definiti all'interno del file OIL di configurazione, e il programmatore deve 
esplicitamente richiamare la funzione \reffun{CounterTick} per incrementarli. 
\end{warning}

\pagebreak

\begin{function}{CounterTick}
  %PJ: vedere il commento
  \synopsis{void CounterTick(CounterType c)}
  \begin{fundescription}
    Questa funzione riceve come parametro un identificatore di Counter e incrementa il relativo 
	contatore di una unita'. Questa funzione viene tipicamente richiamata all'interno di una 
	routine ISR type 2 oppure all'interno di un task.
    
    La funzione implementa anche la notifica degli Alarms scaduti. Tale implementazione dipende 
	dalla configurazione dell'allarme, e puo' essere una delle seguenti:
    \begin{itemize}
      \item una callback function collegata all'Alarm;
      \item l'attivazione di un task;
    \end{itemize}

    La funzione e' atomica, e non avviene alcun rescheduling dopo l'esecuzione di 
	questa funzione. Quando viene chiamata dal livello di un task, per forzare il 
	rescheduling l'applicazione deve chiamare la funzione \reffun{Schedule} dopo la 
	chiamata di questa funzione. Quando la chiamata proviene dal livello di un ISR type 2 
	level, il rescheduling viene automaticamente effettuato alla fine della routine di
	interrupt.
  \end{fundescription}
  \begin{funparameters}
    \fpar{c}{Il contatore che si vuole incrementare.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{La funzione non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{GetAlarm}
  \synopsis{void GetAlarm (AlarmType AlarmID, TickRefType Tick)}
  \begin{fundescription}
    Il servizio di sistema GetAlarm ritorna il valore dei ticks
    che mancano allo scadere dell'allarme \vr{AlarmID}. \vr{AlarmID} {\em deve} essere un
	identificatore valido in uso nel sistema. La chiamata e' disponibile al livello 
	di task, ISR, e in diverse routine di hook.
  \end{fundescription}
  \begin{funparameters}
    \fpar{AlarmID}{Identificatore dell'Alarm}
    \fpar{Tick}{(out) Valore dei ticks mancanti allo scadere dell'allarme}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{La funzione non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{SetRelAlarm}
  \synopsis{void SetRelAlarm (AlarmType AlarmID, TickType increment, TickType cycle)}
  \begin{fundescription}
    Dopo che sono trascorsi \vr{increment} ticks, viene eseguita la notifica 
	\vr{AlarmID}.
    
    Se il valore relativo di \vr{increment} e' molto piccolo, l'allarme potrebbe 
	scadere, e la notifica puo' essere eseguita prima che il servizio ritorni. 
	Se il valore di \vr{cycle} e' diverso da zero, l'allarme viene loggato nuovamente 
	immediatamente dopo che il relativo valore di \vr{cycle} e' scaduto.
    
    L'allarme \vr{AlarmID} non deve essere rgia' in uso al sistema: prima di cambiare
	il valore di un allarme che e' gia' in uso, l'allarme deve essere cancellato. 
	La chiamata e' valida dai livelli task e ISR.
  \end{fundescription}
  \begin{funparameters}
    \fpar{AlarmID}{Riferimento all'allarme}

    \fpar{increment}{Valore relativo in ticks che rappresenta l'offset rispetto all'istante 
	corrente della primo evento di expiration dell'allarme.}

    \fpar{cycle}{Periodo dell'allarme in caso di allarme ciclico. Nel caso in cui si tratti di
	un allarme singolo, questo parametro deve essere impostato a 0.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{La funzione non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{SetAbsAlarm}
  \synopsis{void SetAbsAlarm (AlarmType AlarmID, TickType start, TickType cycle)}
  \begin{fundescription}
    La primitiva occupa l'elemento \vr{AlarmID} del relativo all'allarme. 
	Quando sono raggiunti \vr{start} ticks, la notifica identificata da \vr{AlarmID}
	viene eseguita.
    
    Se il valore assoluto di \vr{start} e' prossimo a quello del valore corrente
	del contatore, l'allarme potrebbe scadere, e il task potrebbe divenire ready 
	o la callback associata all'allarme potrebbe essere richiamata prima che questo
	servizio di sistema sia terminato.
    
    Se il valore assoluto di \vr{start} e' stato gia' raggiunto prima della chiamata
	di sistema, l'allarme dovrebbe solo scadere quando il valore assoluto di \vr{start} 
	viene nuovamente raggiunto, per esempio quando avviene il successivo overrun del 
	contatore.
    
    Se \vr{cycle} e' diverso da zero, l'elemento di allarme viene loggato immediatamente 
	dopo che il relativo valore di \vr{cycle} e' trascorso.
    
    L'allarme \vr{AlarmID} non dovrebbe esser gia' in uso nel sistema: prima di variare il
	valore di un allarme che e' gia' in uso, l'allarme dovrebbe essere cancellato.
	La chiamata puo' essere effettuata al livello di task o in un ISR.
  \end{fundescription}
  \begin{funparameters}
    \fpar{AlarmID}{Riferimento all'allarme.}

    \fpar{start}{Valore assoluto in ticks che rappresenta il tempo al quale si desidera far scadere 
	l'allarme per la prima volta.}

    \fpar{cycle}{Periodo dell'allarme in caso di allarme ciclico. Nel caso in cui si tratti di
	un allarme singolo, questo parametro deve essere impostato a 0.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{La funzione non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{CancelAlarm}
  \synopsis{void CancelAlarm (AlarmType AlarmID)}
  \begin{fundescription}
    La primitiva cancella l'allarme identificato da \vr{AlarmID}. La chiamata e' permessa
	al livello di task o di ISR.
  \end{fundescription}
  \begin{funparameters}
    \fpar{AlarmID}{Riferimento all'allarme}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{La funzione non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Counting Semaphores}

Questa sezione descrive in dettaglio le primitive fornite da \ee\ per
il supporto dei counting semaphores come metodo per implementare la mutua
esclusione e la sincronizzazione tra i task.

Un counting semaphore e' una astrazione tipica dei RTOS nella quale un
contatore intero viene associato ad una coda di bloccaggio. In pratica,
su di un semaforo sono possibili due operazioni: la {\em wait}, che consiste
nel decremento del contatore se il contatore stesso ha un valore maggiore di 0, 
e che si traduce in un bloccaggio del task in esecuzione se il valore del contatore 
e' 0, e la {\em post}, che effettua un incremento del contatore se non ci sono 
task bloccati, oppure si traduce in uno sbloccaggio del task bloccato altrimenti.

In \ee\, l'utilizzo dei counting semaphores avviene mediante una semplice interfaccia
che copre alcune funzionalita' di base, come:
\begin{itemize}
\item L'inizializzazione del semaforo (\reffun{InitSem});
\item La wait sul semaforo in modo bloccante (\reffun{WaitSem}) o in modo 
non-bloccante (\reffun{TryWaitSem};
\item Il post di un semaforo (\reffun{PostSem});
\item La restituzione del valore del contatore relativo al semaforo (\reffun{GetValueSem}).
\end{itemize}

Dal momento che un semaforo puo' provocare il bloccaggio del task in esecuzione,
la primitiva \reffun{WaitSem} dovrebbe essere richiamata solo se il task chiamante 
ha uno stack dedicato, che significa che \ee\ e' stato configurato in modalita' 
multistack).

I semafori possono inoltre essere allocati staticamente come variabili globali. 
Questa opportunita' permette di evitare di inizializzare esplicitamente il semaforo 
chiamando \reffun{InitSem}.

La definizione di un semaforo non viene listata all'interno del file OIL di 
configurazione; le primitive di gestione dei semafori ricevono come parametro 
il puntatore al descrittore del semaforo. 

\begin{warning}
I counting semaphores {\em NON} evitano il problema dell'Inversione di Priorita'. 
Nel caso in cui si voglia evitare l'inversione di priorita' devono essere utilizzare 
le Resources (vedi Sezione \ref{sec:resource-primitives}).
\end{warning}

\pagebreak

\begin{function}{STATICSEM}
  \synopsis{SemType s = STATICSEM(value);}
  \begin{fundescription}
    Questa macro puo' essere utilizzata per inizializzare staticamente un semaforo. 
	La macro deve essere usata all'interno della definizione globale di una variabile 
	che rappresenta il semaforo. Riceve come parametro il valore iniziale da assegnare 
	al semaforo.
	%
	% toOl: what does it mean?!?!?
	%
  \end{fundescription}
  \begin{funparameters}
    \fpar{value}{Il valore del contatore usato per inizializzare il semaforo.}
  \end{funparameters}
  \begin{funreturn}
    \fret{none}{Questa funzione e' una macro e non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{InitSem}
  \synopsis{void InitSem(SemType s, int value);}
  \begin{fundescription}
    Questa macro puo' essere utilizzata per inizializzare un semaforo a runtime. 
	Essa riceve come parametro il valore iniziale da assegnare al semaforo.
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{Il semaforo da inizializzare.}
    \fpar{value}{Il valore da assegnare al contatore associato al semaforo.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{Questa funzione e' una macro e non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{WaitSem}
  \synopsis{void WaitSem(SemRefType s);}
  \begin{fundescription}
    Se il contatore associato al semaforo e' maggiore di 0, allora il contatore 
	viene decrementato di 1. Se il contatore vale 0, allora il task chiamante (running) 
	viene bloccato. Per il corretto funzionamento del sistema, deve essere allocato
	uno stack separato per ciascun task, in quanto il task puo' essere bloccato.
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{Il riferimento al semaforo.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{La funzionee non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{TryWaitSem}
  \synopsis{int TryWaitSem(SemRefType s);}
  \begin{fundescription}
    Questa e' la versione non bloccante di \reffun{SemWait}. Se il contatore del
	semaforo e' maggiore di 0, allora esso viene decrementato di 1 e la primitiva
	ritorna 0. Se il contatore ha valore pari a 0, allora il contatore viene decrementato
	e la primitiva ritorna 1.
	%
	% toOl: e' giusto che avvenga il decremento anche quando il contatore vale 0??
	%
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{Il semaforo utilizzato dalla primitiva.}
  \end{funparameters}
  \begin{funreturn}
    \fret{int}{0 se il contatore e' stato decrementato, altrimenti 1.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{PostSem}
  \synopsis{void PostSem(SemRefType s);}
  \begin{fundescription}
    Questa primitiva sblocca un task eventualmente bloccato dal semaforo. 
	Se non ci sono task bloccati dal semaforo, allora il contatore del semaforo viene 
	incrementato di una unita'.
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{Il semaforo che deve essere utilizzato dalla primitiva.}
  \end{funparameters}
  \begin{funreturn}
    \fret{void}{La funzionee non ritorna alcun errore.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{GetValueSem}
  \synopsis{int GetValueSem(SemRefType s);}
  \begin{fundescription}
    Se non ci sono task bloccati dal semaforo, 
	questa funzione restituisce \const{-1}; 
	altrimenti, la primitiva ritorna il valore
	del contatore associato al semaforo.
  \end{fundescription}
  \begin{funparameters}
    \fpar{s}{Il semaforo che deve essere utilizzato dalla primitiva.}
  \end{funparameters}
  \begin{funreturn}
    \fret{int}{\const{-1} se non ci sono task bloccati sul semaforo,
      altrimenti il valore del contatore associato al semaforo.}
  \end{funreturn}
  \begin{funconformance}
    FP
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Startup del sistema}
\ee\ non richiede una procedura di startup specifica. 
In particolare, il kernel diviene immediatamente attivo dopo la prima 
istruzione della funzione \fn{main}.

Una tipica applicazione viene strutturata con una routine di inizializzazione, 
che dipende dall'applicazione stessa, posta all'interno della funzione \fn{main}. 
A questo punto, i task vengono attivati con una chiamata a \reffun{ActivateTask}.
Successivamente, si raggiunge il loop infinito posto alla fine della funzione
\fn{main}. La funzione \fn{main} diviene cosi' il task di background.
