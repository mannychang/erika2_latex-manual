\chapter{API reference}
\label{sec:api_reference}

\section{Introduction}
% provide an introduction to the OSEK COM stack
\ee\ provides a communication environment according to \oc\ specification, 
version 3.0.3. \oc\ endows \ee\ with a mechanism to transfer data between tasks 
and/or interrupt service routines (ISRs). The communication is based on message 
objects. A message containing application data is sent to sending message objects 
and received by receiving message objects.  Message objects are identified by 
message identifiers. For internal communication, sending messages can store 
messages in zero or more receiving message objects. Zero or more senders can 
send messages to the same sending message object. This allows a n:m communication. 
All message objects are statically defined using the OIL language.    

The current implementation supports internal communication for queue and 
unqueued messages. If a receiving message object is defined as "queued", 
any message received by this object can only be read once and the read 
operation removes the oldest message from the queue. For a receiving message 
object defined as "unqueued", each message can be read more times. The message 
object returns the last received message every time it is read.

%aggiungere due parole sui meccanismi di notifica.
%aggiungere due parole gestione errori.
%aggiungere gli header da includere



\subsection{Communication Conformance Classes}
% provide a description of the available conformance classes and their features
Depending on the specific application and the hardware platform, different 
levels of communication service can be required. \oc\ defines these service 
levels through  Communication Conformance Classes (CCCs). The current version of 
the \ee\ \oc\ implementation provides two conformance classes:

CCCA provides internal communication only. It supports only unqued messages. 
Message status is not supported. It provides the notification mechanism defined 
by Notification Class 1, except for the Flag notification mechanism.

CCCB provides internal communication only. It supports queued and unqued message 
objects. It provides all the notification mechanisms provided by Notification 
Class 1. Moreover, it supports message status information services.

\subsection{Available primitives}
\ee\ provides a set of primitives to exchange messages between tasks according to 
\oc\ specification. The primiteves can be called in different situations. 
The complete list of primitives is listed in Table xx, together with the 
locations where it is legal to call these functions.



\subsection{Notfication Classes}
Only notification class 1 is supported for internal communication. This means 
that the notification mechanism is only used to notify the receiver of a message.

The following notification mechanisms are provided:
\begin{itemize}
\item Callback routines provided by the application;
\item Flags set by the COM layer, read and reset by the application through 
the specific API service;
\item Tasks activated by the COM layer;
\item Events set for application tasks by the COM layer.
\end{itemize}


\pagebreak

\section{Constants}
\label{sec:constants}

This is a list of the \ee\ constants that can be used by the developer
for writing applications that uses the COM support.

\begin{constant}{Error List}
  \begin{constantdescription}
    This is the list of the error values returned by the COM primitives:
    \begin {lstlisting}
#define E_OK                                0
#define E_COM_ID                            1
#define E_COM_LENGTH                        2
#define E_COM_LIMIT                         3
#define E_COM_NOMSG                         4
#define E_COM_SYS_DISCONNECTED              5
    \end{lstlisting}
  \end{constantdescription}
\end{constant}

\begin{constant}{Boolean constants}
  \begin{constantdescription}
    These constants are used to represent boolean values FALSE and TRUE.
    \begin {lstlisting}
#define COM_FALSE                           0
#define COM_TRUE                            1
    \end{lstlisting}
  \end{constantdescription}
\end{constant}

\begin{constant}{COMService IDs}
  \begin{constantdescription}
    This is the list of Service IDs values that can be returned by
    \reffun{COMErrorGetServiceId}:
    \begin {lstlisting}
#define COMServiceId_NoError                    0
#define COMServiceId_StartCOM                   1
#define COMServiceId_StartCOM                   1
#define COMServiceId_StopCOM                    2
#define COMServiceId_GetCOMApplicationMode      3
#define COMServiceId_InitMessage                4
#define COMServiceId_ReadFlag                   7
#define COMServiceId_ResetFlag                  8
#define COMServiceId_SendMessage                9
#define COMServiceId_ReceiveMessage             10
#define COMServiceId_SendZeroMessage            13
#define COMServiceId_GetMessageStatus           14
#define COMServiceId_COMErrorGetServiceId       15

    \end{lstlisting}
  \end{constantdescription}
\end{constant}

\begin{constant}{COM\_SHUTDOWN\_IMMEDIATE}
  \begin{constantdescription}
    This is the default and only possible value for COM Suthdown Mode that can 
    be passed to \reffun{StopCOM}.
  \end{constantdescription}
\end{constant}

\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Types}
\label{sec:types}

This Section contains a description of the data types used by the COM
interface of \ee. When the size of a type is specified to be of the
size of a machine register, it is intended that the type has the same
size of the CPU general purpose register.

\begin{type}{ApplicationDataRef}
  \begin{typedescription}
    This is a pointer to appliation data. This pointer can be passed to 
    \reffun{InitMessage}, \reffun{ReceiveMessage} and \reffun{SendMessage}.  
  \end{typedescription}
\end{type}

\begin{type}{COMApplicationModeType}
  \begin{typedescription}
   This type is an unsigned 8-bit integer type used to store COM Application Mode 
   IDs.
  \end{typedescription}
\end{type}

\begin{type}{COMServiceIdType}
  \begin{typedescription}
    This is an enumeration type used to store COM Service IDs, and it is used 
    within the COMErrorGetServiceId.
  \end{typedescription}
\end{type}

\begin{type}{COMShutdownModeType}
  \begin{typedescription}
    This type is an unsigned 8-bit integer type used to store COM Shutdown Mode 
    IDs. The default and only possibile value is \vr{COM_SHUTDOWN_IMMEDIATE}. 
  \end{typedescription}
\end{type}

\begin{type}{FlagValue}
  \begin{typedescription}
    This is an enumeration type used to store the current state of a message flag.
    Possible values are COM_FALSE and COM_TRUE, see \ref{sec:constants}. 
  \end{typedescription}
\end{type}

\begin{type}{MessageIdentifier}
  \begin{typedescription}
    This is an unsigned char used as ID for a message object.
  \end{typedescription}
\end{type}

\begin{type}{StatusType}
  \begin{typedescription}
    This type is an unsigned char used to store function error return values.
  \end{typedescription}
\end{type}


\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Object Definitions}
The following macro has to be used when defining Message Callbacks.

\begin{function_nopb}{COMCallback}
  \synopsis{COMCallback(c)}
  \begin{fundescription}
    This macro is used to declare and to define a message callback.
  \end{fundescription}
  \begin{funparameters}
    \fpar{c}{Name of the message callback.}
  \end{funparameters}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function_nopb}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{COM Primitives}

% short general description
Put here some introduction words!!!!
\pagebreak

%% 
%% Basic template 
%%
%% \begin{function}{FunctionName}
%% \synopsis{}
%%   \begin{fundescription}
%%   \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
%%   \begin{funreturn}
%%   \fret{}{}
%%   \fret{}{(Extended)}.
%%   \end{funreturn}
%%   \begin{funconformance}
%%     BCC1, BCC2, ECC1, ECC2
%%   \end{funconformance}
%% \end{function}

% provide a list of the functions and of the contexts where they can be called
\begin{function}{StartCOM}
  \synopsis{StatusType StartCOM (COMApplicationModeType Mode)}
  \begin{fundescription}
    The user shall call this primitive to initialise and start the  communication 
    system in a specific application mode, defined by \vr{Mode}. This routine 
    shall be called from a task. When COMSTARTCOMEXTENSION  is set to TRUE 
    within the OIL configuration file, before returning StartCOM calls 
    StartCOMExtension. StartCOMExtension is provided by the application.  
  \end{fundescription}
  \begin{funparameters}
    \fpar{Mode}{COM application mode}
  \end{funparameters}
  \begin{funreturn}
    \fret{E_OK }{ No errors. }
    \fret{A value returned from StartCOMExtension if different from E_OK.}.
    \fret{E_COM_ID}{(Extended) if \vr{Mode} is greater than  \const{EE_COM_N_MODE}.}
  \end{funreturn}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function}

\begin{function}{StopCOM}
  \synopsis{StatusType StopCOM (COMShutdownModeType Mode)}
  \begin{fundescription}
    This primitive is called to terminate all communication activities immidiatly. 
    The only possibile value for \vr{Mode} is \vr{COM_SHUTDOWN_IMMEDIATE}. 
  \end{fundescription}
  \begin{funparameters}
    \fpar{Mode}{Shutdown mode}
  \end{funparameters}
  \begin{funreturn}
    \fret{E_OK }{ No errors. }
    \fret{E_COM_ID}{(Extended) if \vr{Mode} is different from 
      \vr{COM_SHUTDOWN_IMMEDIATE}.}
  \end{funreturn}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function}


\begin{function}{GetCOMApplicationMode}
  \synopsis{COMApplicationModeType GetCOMApplicationMode()}
  \begin{fundescription}
    This primitive returns the current COM application mode. 
    mIt shall not be called before StartCOM.
  \end{fundescription}
  \begin{funparameters}
    \fpar{None}{}
  \end{funparameters}
  \begin{funreturn}
    \fret{Current COM application mode}
  \end{funreturn}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function}

\begin{function}{InitMessage}
  \synopsis{StatusType InitMessage (MessageIdentifier Message, ApplicationDataRef DataRef)}
  \begin{fundescription}
    This primitive 
  \end{fundescription}
  \begin{funparameters}
    \fpar{None}{}
  \end{funparameters}
  \begin{funreturn}
    \fret{StatusType}{StatusType}
  \end{funreturn}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function}

\begin{function}{SendMessage}
  \synopsis{StatusType SendMessage (MessageIdentifier Message, ApplicationDataRef DataRef)}
  \begin{fundescription}
    This primitive 
  \end{fundescription}
  \begin{funparameters}
    \fpar{None}{}
  \end{funparameters}
  \begin{funreturn}
    \fret{StatusType}{StatusType}
  \end{funreturn}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function}

\begin{function}{SendZeroMessage}
  \synopsis{StatusType SendZeroMessage (MessageIdentifier Message)}
  \begin{fundescription}
    This primitive 
  \end{fundescription}
  \begin{funparameters}
    \fpar{None}{}
  \end{funparameters}
  \begin{funreturn}
    \fret{StatusType}{StatusType}
  \end{funreturn}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function}

\begin{function}{RecevieMessage}
  \synopsis{StatusType ReceiveMessage (MessageIdentifier Message, ApplicationDataRef DataRef)}
  \begin{fundescription}
    This primitive 
  \end{fundescription}
  \begin{funparameters}
    \fpar{None}{}
  \end{funparameters}
  \begin{funreturn}
    \fret{StatusType}{StatusType}
  \end{funreturn}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function}

\begin{function}{GetMessageStatus}
  \synopsis{StatusType GetMessageStatus()}
  \begin{fundescription}
    This primitive 
  \end{fundescription}

  \begin{funreturn}
    \fret{}
  \end{funreturn}
  \begin{funconformance}
    CCCB
  \end{funconformance}
\end{function}


\begin{function}{ReadFlag}
	\synopsis{FlagValue ReadFlag_<Flag>()}
	\begin{fundescription}
	This routine reads the status of the flag identified by the name $<$Flag$>$.
   	\end{fundescription}
%   	\begin{funparameters}
 %    	\fpar{None}{None}
 %  	\end{funparameters}
  	\begin{funreturn}
  	\fret{COM_TRUE}{$<$Flag$>$ is set}
   	\fret{COM_TRUE}{$<$Flag$>$ is not set}.
   	\end{funreturn}
	\begin{funconformance}
     	 CCCB
     	\end{funconformance}
\end{function}

\begin{function}{ResetFlag}
	\synopsis{void ResetFlag_<Flag>()}
	\begin{fundescription}
	This routine reset the status of the flag identified by the name $<$Flag$>$.
   	\end{fundescription}

	\begin{funconformance}
     	CCCB
     	\end{funconformance}
\end{function}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Primitives provided by the application}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function_nopb}{StartCOMExtension}
  \synopsis{StatusType StartCOMExtension ()}
  \begin{fundescription}
    This primitive is ...
  \end{fundescription}
  \begin{funreturn}
   \fret{E_OK }{aaa}
   \fret{An implementation specific status code if an error occurred.}
   \end{funreturn}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function_nopb}

\begin{function_nopb}{COMErrorHook}
  \synopsis{void COMErrorHook (StatusType err)}
  \begin{fundescription}
        This primitive is ...
  \end{fundescription}
  \begin{funparameters}
    \fpar{err}{ID of the error.}
  \end{funparameters}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function_nopb}
\pagebreak





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{COMErrorHook and error handling primitives}
\label{sec:errorhook-macros}
These macros are meaningful inside the \reffun{COMErrorHook} Hook
function, and are used to better understand the source of the
error. In particular, \reffun{COMErrorHook} receives as parameter the
error that is raised by the primitive. Then, a call to
\reffun{COMErrorGetServiceId} returns informations about which
primitive caused the error. Finally, calls to the macros
\fn{COMError_XXX_YYY} returns the values of the \const{YYY} parameter
of the primitive \const{XXX}.


\begin{function_nopb2}{COMErrorGetServiceId}
  \synopsis{COMServiceIdType COMErrorGetServiceId (void)}
  \begin{fundescription}
    This function may be used inside \reffun{COMErrorHook} to return the
    Service ID that generated the error that caused the call to
    \reffun{COMErrorHook}. 
  \end{fundescription}
  \begin{funreturn}
    \fret{Service ID}{The service ID causing the error.}
  \end{funreturn}
  \begin{funconformance}
    CCCA, CCCB
  \end{funconformance}
\end{function_nopb2}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
