
\chapter{API reference}
\label{sec:api_reference}

\section{Introduction}
% provide an introduction to the OSEK COM stack
\ee\ provides a communication layer according to \oc\ specification, version 3.0.3. \oc\ endows \ee\ with a mechanism to transfer data between tasks and/or interrupt service routines(ISRs). The communication is based on message objects. A message containing application data is sent to sending message objects and received by receiving message objects.  Message objects are identified by message identifiers. For internal communication, sending messages can store messages in zero or more receiving message objects. Zero or more senders can send messages to the same sending message object. This allows a n:m communication.

All message objects are defined using the OIL language.    

%aggiungere due parole sui message con coda e senza
%aggiungere due parole sui meccanismi di notifica.
%aggiungere due parole gestione errori.
%aggiungere gli header da includere



\subsection{Conformance Classes}
% provide a description of the available conformance classes and their features

% provide a list of the functions and of the contexts where they can be called


%% 
%% Basic template 
%%
%% \begin{function}{FunctionName}
%% \synopsis{}
%%   \begin{fundescription}
%%   \end{fundescription}
%%   \begin{funparameters}
%%     \fpar{}{}
%%   \end{funparameters}
%%   \begin{funreturn}
%%   \fret{}{}
%%   \fret{}{(Extended)}.
%%   \end{funreturn}
%%   \begin{funconformance}
%%     BCC1, BCC2, ECC1, ECC2
%%   \end{funconformance}
%% \end{function}

\subsection{Notfication Classes}
Only notification class 1 is supported for internal communication. 

The following notification mechanisms are provided:
\begin{itemize}
\item Callback routines provided by the application;
\item Flags set by the \os\ layer, read and reset by the application through the specific API service;\item Tasks activated by the \os\ layer;
\item Events set for application tasks by the \os\ layer.
\end{itemize}


%% 
%% Basic template 
%%
\begin{function}{ReadFlag}
	\synopsis{FlagValue ReadFlag_<Flag>()}
	\begin{fundescription}
	This routine reads the status of the flag identified by the name $<$Flag$>$.
   	\end{fundescription}
%   	\begin{funparameters}
 %    	\fpar{None}{None}
 %  	\end{funparameters}
  	\begin{funreturn}
  	\fret{COM_TRUE }{$<$Flag$>$ is set}
   	\fret{COM_TRUE}{$<$Flag$>$ is not set}.
   	\end{funreturn}
	\begin{funconformance}
     	CCCA, CCCB
     	\end{funconformance}
\end{function}

\begin{function}{ResetFlag}
	\synopsis{void ReadFlag_<Flag>()}
	\begin{fundescription}
	This routine reset the status of the flag identified by the name $<$Flag$>$.
   	\end{fundescription}

	\begin{funconformance}
     	CCCA, CCCB
     	\end{funconformance}
\end{function}


\pagebreak

\section{Constants}
\label{sec:constants}

This is a list of the \ee\ constants that can be used by the developer
for writing applications.

\begin{constant}{Error List}
  \begin{constantdescription}
    This is the list of the error values returned by the kernel primitives:
    \begin {lstlisting}
#define E_OK          0
    \end{lstlisting}
  \end{constantdescription}
\end{constant}

\begin{constant2}{INVALID\_TASK}{INVALID_TASK}
  \begin{constantdescription}
    This constant represent an invalid task ID, and is returned by
    \reffun{GetTaskID} when the function is called and no task is
    running.
  \end{constantdescription}
\end{constant2}

\begin{constant}{OSService IDs}
  \begin{constantdescription}
    This is the list of Service IDs values that can be returned by
    \reffun{OSErrorGetServiceId}:
    \begin {lstlisting}
#define OSServiceId_ActivateTask      1U
    \end{lstlisting}
    Please note that the primitives:
    \begin{itemize}                              \vspace{-2mm}
      \item \reffun{DisableAllInterrupts}        \vspace{-2mm}
    \end{itemize}
    never return an error, and for that reason they are not listed
    here.
  \end{constantdescription}
\end{constant}

\begin{constant}{OSDEFAULTAPPMODE}
  \begin{constantdescription}
    This is the default Application Mode. This value is always a valid
    Application Mode that can be passed to \reffun{StartOS}.
  \end{constantdescription}
\end{constant}


\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Types}
\label{sec:types}

This Section contains a description of the data types used by the OS
interface of \ee. When the size of a type is specified to be of the
size of a machine register, it is intended that the type has the same
size of the CPU general purpose register.

\begin{type}{AlarmBaseType}
  \begin{typedescription}
    This structure is used to store the basic information about
    Counters. It has the following fields:
    \begin{description}
    \item[TickType maxallowedvalue] Is the maximum allowed count value
      in ticks for a counter.
    \item[TickType ticksperbase] It is the number of ticks required to
      reach a counter-specific significant unit.
    \item[TickType mincycle] It is the smallest allowed value for the
      \vr{cycle} parameter of the primitives 
      \reffun{SetRelAlarm}/\reffun{SetAbsAlarm}. This field is only
      present when Extended status is selected.
    \end{description}
  \end{typedescription}
\end{type}

\begin{type}{AlarmBaseRefType}
  \begin{typedescription}
    This is a pointer to \reftype{AlarmBaseType}.
  \end{typedescription}
\end{type}


\pagebreak






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Object Declarations}
The following declarations have to be used to declare Tasks, Resources,
Alarms, and Events within the application code.

\begin{function_nopb}{DeclareAlarm}
  \synopsis{DeclareAlarm (AlarmIdentifier)}
  \begin{fundescription}
    Declares an alarm.

    This declaration is currently not mandatory because alarm
    identifiers are all declared within the code generated by \rtd.
  \end{fundescription}
  \begin{funconformance}
    BCC1, BCC2, ECC1, ECC2
  \end{funconformance}
\end{function_nopb}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Object Definitions}
The following macro have to be used when defining Tasks, ISRs and
Alarm Callbacks.

\begin{function_nopb}{ALARMCALLBACK}
  \synopsis{ALARMCALLBACK(t)}
  \begin{fundescription}
    This macro is used to declare and to define an alarm callback.
  \end{fundescription}
  \begin{funparameters}
    \fpar{t}{Name of the alarm callback.}
  \end{funparameters}
  %  \begin{funreturn}
  %    \fret{E_OK}{No error.}
  %  \end{funreturn}
  \begin{funconformance}
    BCC1, BCC2, ECC1, ECC2
  \end{funconformance}
\end{function_nopb}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%










\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{XXX Primitives}

% short general description

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function}{ActivateTask}
  \synopsis{StatusType ActivateTask(TaskType TaskID);}
  
  \begin{fundescription}
    This primitive activates a task \vr{TaskID}, putting it in the
    \const{READY} state, or in the \const{RUNNING} state if the
    scheduler finds that the activated task should become the running
    task.

    Once activated, the task will run for an instance, starting from
    its first instruction. For the BCC2 and ECC2 Conformance classes,
    pending activations can be stored if the task has been configured
    with a number of activations greater than 1 within the OIL
    configuration file.

    The function can be called from the Background task (typically,
    the \fn{main()} function).

  \end{fundescription}
  
  \begin{funparameters}
    \fpar{TaskID}{Task reference.}
  \end{funparameters}
  
  \begin{funreturn}
    \fret{E_OK}{No error.}
    \fret{E_OS_LIMIT}{Too many pending activations of \vr{TaskID}.}
    \fret{E_OS_ID}{(Extended) \vr{TaskID} is invalid.}
  \end{funreturn}
  
  \begin{funconformance}
    BCC1, BCC2, ECC1, ECC2
  \end{funconformance}
\end{function}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{ErrorHook Macros}
\label{sec:errorhook-macros}
These macros are meaningful inside the \reffun{ErrorHook} Hook
function, and are used to better understand the source of the
error. In particular, \reffun{ErrorHook} receives as parameter the
error that is raised by the primitive. Then, a call to
\reffun{OSErrorGetServiceId} returns informations about which
primitive caused the error. Finally, calls to the macros
\fn{OSError_XXX_YYY} returns the values of the \const{YYY} parameter
of the primitive \const{XXX}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{function_nopb2}{OSErrorGetServiceId}{OSErrorGetServiceId}
  \synopsis{OSServiceIdType OSErrorGetServiceId(void)}
  \begin{fundescription}
    The function may be used inside \reffun{ErrorHook} to return the
    Service ID that generated the error that caused the call to
    \reffun{ErrorHook}.
  \end{fundescription}
  \begin{funreturn}
    \fret{Service ID}{The service ID causing the error.}
  \end{funreturn}
  \begin{funconformance}
    BCC1, BCC2, ECC1, ECC2
  \end{funconformance}
\end{function_nopb2}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
